// Generated by the C# M2TypesGenerator: modify at your own risk!
// ReSharper disable InconsistentNaming
// ReSharper disable SuggestVarOrType_SimpleTypes
// ReSharper disable SuggestVarOrType_Elsewhere
#pragma warning disable 1591
#nullable enable
namespace LionWeb.Core.Test.Languages.Generated.V2023_1.GeneralNodeLang;
using LionWeb.Core;
using LionWeb.Core.M2;
using LionWeb.Core.M3;
using LionWeb.Core.Notification;
using LionWeb.Core.Notification.Partition.Emitter;
using LionWeb.Core.Utilities;
using LionWeb.Core.VersionSpecific.V2023_1;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

[LionCoreLanguage(Key = "key-GeneralNodeLang", Version = "1")]
public partial class GeneralNodeLangLanguage : LanguageBase<IGeneralNodeLangFactory>
{
	public static readonly GeneralNodeLangLanguage Instance = new Lazy<GeneralNodeLangLanguage>(() => new("id-GeneralNodeLang")).Value;
	public GeneralNodeLangLanguage(string id) : base(id, LionWebVersions.v2023_1)
	{
		_generalNodeConcept = new(() => new ConceptBase<GeneralNodeLangLanguage>("id-GeneralNodeConcept", this) { Key = "key-GeneralNodeConcept", Name = "GeneralNodeConcept", Abstract = false, Partition = false, FeaturesLazy = new(() => [GeneralNodeConcept_multipleContainment, GeneralNodeConcept_multipleRef, GeneralNodeConcept_singleContainment, GeneralNodeConcept_singleRef]) });
		_generalNodeConcept_multipleContainment = new(() => new ContainmentBase<GeneralNodeLangLanguage>("id-multipleContainment", GeneralNodeConcept, this) { Key = "key-multipleContainment", Name = "multipleContainment", Optional = false, Multiple = true, Type = _builtIns.Node });
		_generalNodeConcept_multipleRef = new(() => new ReferenceBase<GeneralNodeLangLanguage>("id-multipleRef", GeneralNodeConcept, this) { Key = "key-multipleRef", Name = "multipleRef", Optional = false, Multiple = true, Type = _builtIns.Node });
		_generalNodeConcept_singleContainment = new(() => new ContainmentBase<GeneralNodeLangLanguage>("id-singleContainment", GeneralNodeConcept, this) { Key = "key-singleContainment", Name = "singleContainment", Optional = false, Multiple = false, Type = _builtIns.Node });
		_generalNodeConcept_singleRef = new(() => new ReferenceBase<GeneralNodeLangLanguage>("id-singleRef", GeneralNodeConcept, this) { Key = "key-singleRef", Name = "singleRef", Optional = false, Multiple = false, Type = _builtIns.Node });
		_factory = new GeneralNodeLangFactory(this);
	}

	/// <inheritdoc/>
        public override IReadOnlyList<LanguageEntity> Entities => [GeneralNodeConcept];
	/// <inheritdoc/>
        public override IReadOnlyList<Language> DependsOn => [];

	private const string _key = "key-GeneralNodeLang";
	/// <inheritdoc/>
        public override string Key => _key;

	private const string _name = "GeneralNodeLang";
	/// <inheritdoc/>
        public override string Name => _name;

	private const string _version = "1";
	/// <inheritdoc/>
        public override string Version => _version;

	private readonly Lazy<Concept> _generalNodeConcept;
	public Concept GeneralNodeConcept => _generalNodeConcept.Value;

	private readonly Lazy<Containment> _generalNodeConcept_multipleContainment;
	public Containment GeneralNodeConcept_multipleContainment => _generalNodeConcept_multipleContainment.Value;

	private readonly Lazy<Reference> _generalNodeConcept_multipleRef;
	public Reference GeneralNodeConcept_multipleRef => _generalNodeConcept_multipleRef.Value;

	private readonly Lazy<Containment> _generalNodeConcept_singleContainment;
	public Containment GeneralNodeConcept_singleContainment => _generalNodeConcept_singleContainment.Value;

	private readonly Lazy<Reference> _generalNodeConcept_singleRef;
	public Reference GeneralNodeConcept_singleRef => _generalNodeConcept_singleRef.Value;
}

public partial interface IGeneralNodeLangFactory : INodeFactory
{
	public GeneralNodeConcept NewGeneralNodeConcept(string id);
	public GeneralNodeConcept CreateGeneralNodeConcept();
}

public class GeneralNodeLangFactory : AbstractBaseNodeFactory, IGeneralNodeLangFactory
{
	private readonly GeneralNodeLangLanguage _language;
	public GeneralNodeLangFactory(GeneralNodeLangLanguage language) : base(language)
	{
		_language = language;
	}

	/// <inheritdoc/>
        public override INode CreateNode(string id, Classifier classifier)
	{
		if (_language.GeneralNodeConcept.EqualsIdentity(classifier))
			return NewGeneralNodeConcept(id);
		throw new UnsupportedClassifierException(classifier);
	}

	/// <inheritdoc/>
        public override Enum GetEnumerationLiteral(EnumerationLiteral literal)
	{
		throw new UnsupportedEnumerationLiteralException(literal);
	}

	/// <inheritdoc/>
        public override IStructuredDataTypeInstance CreateStructuredDataTypeInstance(StructuredDataType structuredDataType, IFieldValues fieldValues)
	{
		throw new UnsupportedStructuredDataTypeException(structuredDataType);
	}

	public virtual GeneralNodeConcept NewGeneralNodeConcept(string id) => new(id);
	public virtual GeneralNodeConcept CreateGeneralNodeConcept() => NewGeneralNodeConcept(GetNewId());
}

[LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-GeneralNodeConcept")]
public partial class GeneralNodeConcept : ConceptInstanceBase
{
	private readonly List<IReadableNode> _multipleContainment = [];
	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If MultipleContainment is empty</exception>
        [LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-multipleContainment")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = true)]
	public IReadOnlyList<IReadableNode> MultipleContainment { get => AsNonEmptyReadOnly(_multipleContainment, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment); init => AddMultipleContainment(value); }

	/// <remarks>Required Multiple Containment</remarks>
        public bool TryGetMultipleContainment([NotNullWhenAttribute(true)] out IReadOnlyList<IReadableNode> multipleContainment)
	{
		multipleContainment = _multipleContainment;
		return _multipleContainment.Count != 0;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If both MultipleContainment and nodes are empty</exception>
        public GeneralNodeConcept AddMultipleContainment(IEnumerable<IReadableNode> nodes, INotificationId? notificationId = null)
	{
		var safeNodes = nodes?.ToList();
		AssureNonEmpty(safeNodes, _multipleContainment, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment);
		ContainmentAddMultipleNotificationEmitter<IReadableNode> emitter = new(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment, this, safeNodes, _multipleContainment, null, notificationId);
		emitter.CollectOldData();
		_multipleContainment.AddRange(SetSelfParent(safeNodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment));
		emitter.Notify();
		return this;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If both MultipleContainment and nodes are empty</exception>
    	/// <exception cref = "ArgumentOutOfRangeException">If index negative or greater than MultipleContainment.Count</exception>
        public GeneralNodeConcept InsertMultipleContainment(int index, IEnumerable<IReadableNode> nodes, INotificationId? notificationId = null)
	{
		AssureInRange(index, _multipleContainment);
		var safeNodes = nodes?.ToList();
		AssureNonEmpty(safeNodes, _multipleContainment, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment);
		AssureNoSelfMove(index, safeNodes, _multipleContainment);
		ContainmentAddMultipleNotificationEmitter<IReadableNode> emitter = new(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment, this, safeNodes, _multipleContainment, index, notificationId);
		emitter.CollectOldData();
		_multipleContainment.InsertRange(index, SetSelfParent(safeNodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment));
		emitter.Notify();
		return this;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If MultipleContainment would be empty</exception>
        public GeneralNodeConcept RemoveMultipleContainment(IEnumerable<IReadableNode> nodes, INotificationId? notificationId = null)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment);
		AssureNotClearing(safeNodes, _multipleContainment, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment);
		RemoveSelfParent(safeNodes, _multipleContainment, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment, ContainmentRemover<IReadableNode>(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment));
		return this;
	}

	private readonly List<IReadableNode> _multipleRef = [];
	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If MultipleRef is empty</exception>
        [LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-multipleRef")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = true)]
	public IReadOnlyList<IReadableNode> MultipleRef { get => AsNonEmptyReadOnly(_multipleRef, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef); init => AddMultipleRef(value); }

	/// <remarks>Required Multiple Reference</remarks>
        public bool TryGetMultipleRef([NotNullWhenAttribute(true)] out IReadOnlyList<IReadableNode> multipleRef)
	{
		multipleRef = _multipleRef;
		return _multipleRef.Count != 0;
	}

	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If both MultipleRef and nodes are empty</exception>
        public GeneralNodeConcept AddMultipleRef(IEnumerable<IReadableNode> nodes, INotificationId? notificationId = null)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef);
		AssureNonEmpty(safeNodes, _multipleRef, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef);
		ReferenceAddMultipleNotificationEmitter<IReadableNode> emitter = new(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef, this, safeNodes, _multipleRef.Count, notificationId);
		emitter.CollectOldData();
		_multipleRef.AddRange(safeNodes);
		emitter.Notify();
		return this;
	}

	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If both MultipleRef and nodes are empty</exception>
    	/// <exception cref = "ArgumentOutOfRangeException">If index negative or greater than MultipleRef.Count</exception>
        public GeneralNodeConcept InsertMultipleRef(int index, IEnumerable<IReadableNode> nodes, INotificationId? notificationId = null)
	{
		AssureInRange(index, _multipleRef);
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef);
		AssureNonEmpty(safeNodes, _multipleRef, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef);
		ReferenceAddMultipleNotificationEmitter<IReadableNode> emitter = new(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef, this, safeNodes, index, notificationId);
		emitter.CollectOldData();
		_multipleRef.InsertRange(index, safeNodes);
		emitter.Notify();
		return this;
	}

	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If MultipleRef would be empty</exception>
        public GeneralNodeConcept RemoveMultipleRef(IEnumerable<IReadableNode> nodes, INotificationId? notificationId = null)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef);
		AssureNonEmpty(safeNodes, _multipleRef, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef);
		AssureNotClearing(safeNodes, _multipleRef, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef);
		RemoveAll(safeNodes, _multipleRef, ReferenceRemover<IReadableNode>(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef));
		return this;
	}

	private INode? _singleContainment = null;
	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If SingleContainment has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-singleContainment")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = false)]
	public INode SingleContainment { get => _singleContainment ?? throw new UnsetFeatureException(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment); set => SetSingleContainment(value); }

	/// <remarks>Required Single Containment</remarks>
        public bool TryGetSingleContainment([NotNullWhenAttribute(true)] out INode? singleContainment)
	{
		singleContainment = _singleContainment;
		return _singleContainment != null;
	}

	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public GeneralNodeConcept SetSingleContainment(INode value, INotificationId? notificationId = null)
	{
		AssureNotNull(value, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment);
		ContainmentSingleNotificationEmitter<INode> emitter = new(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment, this, value, _singleContainment, notificationId);
		emitter.CollectOldData();
		SetParentNull(_singleContainment);
		AttachChild(value);
		_singleContainment = value;
		emitter.Notify();
		return this;
	}

	private IReadableNode? _singleRef = null;
	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If SingleRef has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-singleRef")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = false)]
	public IReadableNode SingleRef { get => _singleRef ?? throw new UnsetFeatureException(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef); set => SetSingleRef(value); }

	/// <remarks>Required Single Reference</remarks>
        public bool TryGetSingleRef([NotNullWhenAttribute(true)] out IReadableNode? singleRef)
	{
		singleRef = _singleRef;
		return _singleRef != null;
	}

	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public GeneralNodeConcept SetSingleRef(IReadableNode value, INotificationId? notificationId = null)
	{
		AssureNotNull(value, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef);
		ReferenceSingleNotificationEmitter emitter = new(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef, this, value, _singleRef, notificationId);
		emitter.CollectOldData();
		_singleRef = value;
		emitter.Notify();
		return this;
	}

	public GeneralNodeConcept(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => GeneralNodeLangLanguage.Instance.GeneralNodeConcept;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(feature))
		{
			result = MultipleContainment;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.EqualsIdentity(feature))
		{
			result = MultipleRef;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment.EqualsIdentity(feature))
		{
			result = SingleContainment;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef.EqualsIdentity(feature))
		{
			result = SingleRef;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(feature))
		{
			var safeNodes = GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.AsNodes<IReadableNode>(value).ToList();
			AssureNonEmpty(safeNodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment);
			ContainmentSetNotificationEmitter<IReadableNode> emitter = new(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment, this, safeNodes, _multipleContainment, notificationId);
			emitter.CollectOldData();
			RemoveSelfParent(_multipleContainment.ToList(), _multipleContainment, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment);
			_multipleContainment.AddRange(SetSelfParent(safeNodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment));
			emitter.Notify();
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.EqualsIdentity(feature))
		{
			var safeNodes = GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.AsNodes<IReadableNode>(value).ToList();
			AssureNonEmpty(safeNodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef);
			ReferenceSetNotificationEmitter<IReadableNode> emitter = new(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef, this, safeNodes, _multipleRef, notificationId);
			emitter.CollectOldData();
			_multipleRef.Clear();
			_multipleRef.AddRange(safeNodes);
			emitter.Notify();
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment.EqualsIdentity(feature))
		{
			if (value is INode v)
			{
				SetSingleContainment(v, notificationId);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef.EqualsIdentity(feature))
		{
			if (value is IReadableNode v)
			{
				SetSingleRef(v, notificationId);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetMultipleContainment(out _))
			result.Add(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment);
		if (TryGetMultipleRef(out _))
			result.Add(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef);
		if (TryGetSingleContainment(out _))
			result.Add(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment);
		if (TryGetSingleRef(out _))
			result.Add(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef);
		return result;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _multipleContainment, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment);
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment.EqualsIdentity(c))
		{
			_singleContainment = null;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (child is IReadableNode child0 && _multipleContainment.Contains(child0))
			return GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment;
		if (ReferenceEquals(_singleContainment, child))
			return GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment;
		return null;
	}
}