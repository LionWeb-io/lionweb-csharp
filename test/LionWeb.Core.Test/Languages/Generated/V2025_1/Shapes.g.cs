// Generated by the C# M2TypesGenerator: modify at your own risk!
// ReSharper disable InconsistentNaming
// ReSharper disable SuggestVarOrType_SimpleTypes
// ReSharper disable SuggestVarOrType_Elsewhere
#pragma warning disable 1591
#nullable enable
namespace LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2;
using LionWeb.Core;
using LionWeb.Core.M2;
using LionWeb.Core.M3;
using LionWeb.Core.Notification;
using LionWeb.Core.Notification.Partition;
using LionWeb.Core.Notification.Partition.Emitter;
using LionWeb.Core.Notification.Pipe;
using LionWeb.Core.Utilities;
using LionWeb.Core.VersionSpecific.V2025_1;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Time = string;

[LionCoreLanguage(Key = "key-Shapes", Version = "1")]
public partial class ShapesLanguage : LanguageBase<IShapesFactory>
{
	public static readonly ShapesLanguage Instance = new Lazy<ShapesLanguage>(() => new("id-Shapes")).Value;
	public ShapesLanguage(string id) : base(id, LionWebVersions.v2025_1)
	{
		_billOfMaterials = new(() => new AnnotationBase<ShapesLanguage>("id-BillOfMaterials", this) { Key = "key-BillOfMaterials", Name = "BillOfMaterials", AnnotatesLazy = new(() => _builtIns.Node), FeaturesLazy = new(() => [BillOfMaterials_altGroups, BillOfMaterials_defaultGroup, BillOfMaterials_groups, BillOfMaterials_materials]) });
		_billOfMaterials_altGroups = new(() => new ContainmentBase<ShapesLanguage>("id-alt-groups", BillOfMaterials, this) { Key = "key-alt-groups", Name = "altGroups", Optional = true, Multiple = true, Type = MaterialGroup });
		_billOfMaterials_defaultGroup = new(() => new ContainmentBase<ShapesLanguage>("id-default-group", BillOfMaterials, this) { Key = "key-default-group", Name = "defaultGroup", Optional = true, Multiple = false, Type = MaterialGroup });
		_billOfMaterials_groups = new(() => new ContainmentBase<ShapesLanguage>("id-groups", BillOfMaterials, this) { Key = "key-groups", Name = "groups", Optional = true, Multiple = true, Type = MaterialGroup });
		_billOfMaterials_materials = new(() => new ReferenceBase<ShapesLanguage>("id-materials", BillOfMaterials, this) { Key = "key-materials", Name = "materials", Optional = true, Multiple = true, Type = IShape });
		_circle = new(() => new ConceptBase<ShapesLanguage>("id-Circle", this) { Key = "key-Circle", Name = "Circle", Abstract = false, Partition = false, ExtendsLazy = new(() => Shape), FeaturesLazy = new(() => [Circle_center, Circle_r]) });
		_circle_center = new(() => new ContainmentBase<ShapesLanguage>("id-center", Circle, this) { Key = "key-center", Name = "center", Optional = false, Multiple = false, Type = Coord });
		_circle_r = new(() => new PropertyBase<ShapesLanguage>("id-r", Circle, this) { Key = "key-r", Name = "r", Optional = false, Type = _builtIns.Integer });
		_compositeShape = new(() => new ConceptBase<ShapesLanguage>("id-CompositeShape", this) { Key = "key-CompositeShape", Name = "CompositeShape", Abstract = false, Partition = false, ExtendsLazy = new(() => Shape), FeaturesLazy = new(() => [CompositeShape_disabledParts, CompositeShape_evilPart, CompositeShape_parts]) });
		_compositeShape_disabledParts = new(() => new ContainmentBase<ShapesLanguage>("id-disabled-parts", CompositeShape, this) { Key = "key-disabled-parts", Name = "disabledParts", Optional = false, Multiple = true, Type = IShape });
		_compositeShape_evilPart = new(() => new ContainmentBase<ShapesLanguage>("id-evil-part", CompositeShape, this) { Key = "key-evil-part", Name = "evilPart", Optional = false, Multiple = false, Type = IShape });
		_compositeShape_parts = new(() => new ContainmentBase<ShapesLanguage>("id-parts", CompositeShape, this) { Key = "key-parts", Name = "parts", Optional = false, Multiple = true, Type = IShape });
		_coord = new(() => new ConceptBase<ShapesLanguage>("id-Coord", this) { Key = "key-Coord", Name = "Coord", Abstract = false, Partition = false, FeaturesLazy = new(() => [Coord_x, Coord_y, Coord_z]) });
		_coord_x = new(() => new PropertyBase<ShapesLanguage>("id-x", Coord, this) { Key = "key-x", Name = "x", Optional = false, Type = _builtIns.Integer });
		_coord_y = new(() => new PropertyBase<ShapesLanguage>("id-y", Coord, this) { Key = "key-y", Name = "y", Optional = false, Type = _builtIns.Integer });
		_coord_z = new(() => new PropertyBase<ShapesLanguage>("id-z", Coord, this) { Key = "key-z", Name = "z", Optional = false, Type = _builtIns.Integer });
		_documentation = new(() => new AnnotationBase<ShapesLanguage>("id-Documentation", this) { Key = "key-Documentation", Name = "Documentation", AnnotatesLazy = new(() => Shape), FeaturesLazy = new(() => [Documentation_technical, Documentation_text]) });
		_documentation_technical = new(() => new PropertyBase<ShapesLanguage>("id-technical", Documentation, this) { Key = "key-technical", Name = "technical", Optional = true, Type = _builtIns.Boolean });
		_documentation_text = new(() => new PropertyBase<ShapesLanguage>("id-text", Documentation, this) { Key = "key-text", Name = "text", Optional = true, Type = _builtIns.String });
		_geometry = new(() => new ConceptBase<ShapesLanguage>("id-Geometry", this) { Key = "key-Geometry", Name = "Geometry", Abstract = false, Partition = true, FeaturesLazy = new(() => [Geometry_documentation, Geometry_shapes]) });
		_geometry_documentation = new(() => new ContainmentBase<ShapesLanguage>("id-documentation", Geometry, this) { Key = "key-documentation", Name = "documentation", Optional = true, Multiple = false, Type = Documentation });
		_geometry_shapes = new(() => new ContainmentBase<ShapesLanguage>("id-shapes", Geometry, this) { Key = "key-shapes", Name = "shapes", Optional = true, Multiple = true, Type = IShape });
		_iShape = new(() => new InterfaceBase<ShapesLanguage>("id-IShape", this) { Key = "key-IShape", Name = "IShape", FeaturesLazy = new(() => [IShape_fixpoints, IShape_uuid]) });
		_iShape_fixpoints = new(() => new ContainmentBase<ShapesLanguage>("id-fixpoints", IShape, this) { Key = "key-fixpoints", Name = "fixpoints", Optional = true, Multiple = true, Type = Coord });
		_iShape_uuid = new(() => new PropertyBase<ShapesLanguage>("id-uuid", IShape, this) { Key = "key-uuid", Name = "uuid", Optional = false, Type = _builtIns.String });
		_line = new(() => new ConceptBase<ShapesLanguage>("id-Line", this) { Key = "key-Line", Name = "Line", Abstract = false, Partition = false, ExtendsLazy = new(() => Shape), ImplementsLazy = new(() => [_builtIns.INamed]), FeaturesLazy = new(() => [Line_end, Line_start]) });
		_line_end = new(() => new ContainmentBase<ShapesLanguage>("id-end", Line, this) { Key = "key-end", Name = "end", Optional = false, Multiple = false, Type = Coord });
		_line_start = new(() => new ContainmentBase<ShapesLanguage>("id-start", Line, this) { Key = "key-start", Name = "start", Optional = false, Multiple = false, Type = Coord });
		_materialGroup = new(() => new ConceptBase<ShapesLanguage>("id-MaterialGroup", this) { Key = "key-MaterialGroup", Name = "MaterialGroup", Abstract = false, Partition = false, FeaturesLazy = new(() => [MaterialGroup_defaultShape, MaterialGroup_materials, MaterialGroup_matterState]) });
		_materialGroup_defaultShape = new(() => new ContainmentBase<ShapesLanguage>("id-default-shape", MaterialGroup, this) { Key = "key-default-shape", Name = "defaultShape", Optional = true, Multiple = false, Type = IShape });
		_materialGroup_materials = new(() => new ReferenceBase<ShapesLanguage>("id-group-materials", MaterialGroup, this) { Key = "key-group-materials", Name = "materials", Optional = false, Multiple = true, Type = IShape });
		_materialGroup_matterState = new(() => new PropertyBase<ShapesLanguage>("id-matter-state", MaterialGroup, this) { Key = "key-matter-state", Name = "matterState", Optional = true, Type = MatterState });
		_matterState = new(() => new EnumerationBase<ShapesLanguage>("id-MatterState", this) { Key = "key-MatterState", Name = "MatterState", LiteralsLazy = new(() => [MatterState_gas, MatterState_liquid, MatterState_solid]) });
		_matterState_gas = new(() => new EnumerationLiteralBase<ShapesLanguage>("id-gas", MatterState, this) { Key = "key-gas", Name = "gas" });
		_matterState_liquid = new(() => new EnumerationLiteralBase<ShapesLanguage>("id-liquid", MatterState, this) { Key = "key-liquid", Name = "liquid" });
		_matterState_solid = new(() => new EnumerationLiteralBase<ShapesLanguage>("id-solid", MatterState, this) { Key = "key-solid", Name = "solid" });
		_offsetDuplicate = new(() => new ConceptBase<ShapesLanguage>("id-OffsetDuplicate", this) { Key = "key-OffsetDuplicate", Name = "OffsetDuplicate", Abstract = false, Partition = false, ExtendsLazy = new(() => Shape), FeaturesLazy = new(() => [OffsetDuplicate_altSource, OffsetDuplicate_docs, OffsetDuplicate_offset, OffsetDuplicate_secretDocs, OffsetDuplicate_source]) });
		_offsetDuplicate_altSource = new(() => new ReferenceBase<ShapesLanguage>("id-alt-source", OffsetDuplicate, this) { Key = "key-alt-source", Name = "altSource", Optional = true, Multiple = false, Type = Shape });
		_offsetDuplicate_docs = new(() => new ContainmentBase<ShapesLanguage>("id-docs", OffsetDuplicate, this) { Key = "key-docs", Name = "docs", Optional = true, Multiple = false, Type = Documentation });
		_offsetDuplicate_offset = new(() => new ContainmentBase<ShapesLanguage>("id-offset", OffsetDuplicate, this) { Key = "key-offset", Name = "offset", Optional = false, Multiple = false, Type = Coord });
		_offsetDuplicate_secretDocs = new(() => new ContainmentBase<ShapesLanguage>("id-secret-docs", OffsetDuplicate, this) { Key = "key-secret-docs", Name = "secretDocs", Optional = true, Multiple = false, Type = Documentation });
		_offsetDuplicate_source = new(() => new ReferenceBase<ShapesLanguage>("id-source", OffsetDuplicate, this) { Key = "key-source", Name = "source", Optional = false, Multiple = false, Type = Shape });
		_referenceGeometry = new(() => new ConceptBase<ShapesLanguage>("id-ReferenceGeometry", this) { Key = "key-ReferenceGeometry", Name = "ReferenceGeometry", Abstract = false, Partition = true, FeaturesLazy = new(() => [ReferenceGeometry_shapes]) });
		_referenceGeometry_shapes = new(() => new ReferenceBase<ShapesLanguage>("id-shape-references", ReferenceGeometry, this) { Key = "key-shapes-references", Name = "shapes", Optional = true, Multiple = true, Type = IShape });
		_shape = new(() => new ConceptBase<ShapesLanguage>("id-Shape", this) { Key = "key-Shape", Name = "Shape", Abstract = true, Partition = false, ImplementsLazy = new(() => [_builtIns.INamed, IShape]), FeaturesLazy = new(() => [Shape_shapeDocs]) });
		_shape_shapeDocs = new(() => new ContainmentBase<ShapesLanguage>("id-shape-docs", Shape, this) { Key = "key-shape-docs", Name = "shapeDocs", Optional = true, Multiple = false, Type = Documentation });
		_time = new(() => new PrimitiveTypeBase<ShapesLanguage>("id-Time", this) { Key = "key-Time", Name = "Time" });
		_factory = new ShapesFactory(this);
	}

	/// <inheritdoc/>
        public override IReadOnlyList<LanguageEntity> Entities => [BillOfMaterials, Circle, CompositeShape, Coord, Documentation, Geometry, IShape, Line, MaterialGroup, MatterState, OffsetDuplicate, ReferenceGeometry, Shape];
	/// <inheritdoc/>
        public override IReadOnlyList<Language> DependsOn => [];

	private const string _key = "key-Shapes";
	/// <inheritdoc/>
        public override string Key => _key;

	private const string _name = "Shapes";
	/// <inheritdoc/>
        public override string Name => _name;

	private const string _version = "1";
	/// <inheritdoc/>
        public override string Version => _version;

	private readonly Lazy<Annotation> _billOfMaterials;
	public Annotation BillOfMaterials => _billOfMaterials.Value;

	private readonly Lazy<Containment> _billOfMaterials_altGroups;
	public Containment BillOfMaterials_altGroups => _billOfMaterials_altGroups.Value;

	private readonly Lazy<Containment> _billOfMaterials_defaultGroup;
	public Containment BillOfMaterials_defaultGroup => _billOfMaterials_defaultGroup.Value;

	private readonly Lazy<Containment> _billOfMaterials_groups;
	public Containment BillOfMaterials_groups => _billOfMaterials_groups.Value;

	private readonly Lazy<Reference> _billOfMaterials_materials;
	public Reference BillOfMaterials_materials => _billOfMaterials_materials.Value;

	private readonly Lazy<Concept> _circle;
	public Concept Circle => _circle.Value;

	private readonly Lazy<Containment> _circle_center;
	public Containment Circle_center => _circle_center.Value;

	private readonly Lazy<Property> _circle_r;
	public Property Circle_r => _circle_r.Value;

	private readonly Lazy<Concept> _compositeShape;
	public Concept CompositeShape => _compositeShape.Value;

	private readonly Lazy<Containment> _compositeShape_disabledParts;
	public Containment CompositeShape_disabledParts => _compositeShape_disabledParts.Value;

	private readonly Lazy<Containment> _compositeShape_evilPart;
	public Containment CompositeShape_evilPart => _compositeShape_evilPart.Value;

	private readonly Lazy<Containment> _compositeShape_parts;
	public Containment CompositeShape_parts => _compositeShape_parts.Value;

	private readonly Lazy<Concept> _coord;
	public Concept Coord => _coord.Value;

	private readonly Lazy<Property> _coord_x;
	public Property Coord_x => _coord_x.Value;

	private readonly Lazy<Property> _coord_y;
	public Property Coord_y => _coord_y.Value;

	private readonly Lazy<Property> _coord_z;
	public Property Coord_z => _coord_z.Value;

	private readonly Lazy<Annotation> _documentation;
	public Annotation Documentation => _documentation.Value;

	private readonly Lazy<Property> _documentation_technical;
	public Property Documentation_technical => _documentation_technical.Value;

	private readonly Lazy<Property> _documentation_text;
	public Property Documentation_text => _documentation_text.Value;

	private readonly Lazy<Concept> _geometry;
	public Concept Geometry => _geometry.Value;

	private readonly Lazy<Containment> _geometry_documentation;
	public Containment Geometry_documentation => _geometry_documentation.Value;

	private readonly Lazy<Containment> _geometry_shapes;
	public Containment Geometry_shapes => _geometry_shapes.Value;

	private readonly Lazy<Interface> _iShape;
	public Interface IShape => _iShape.Value;

	private readonly Lazy<Containment> _iShape_fixpoints;
	public Containment IShape_fixpoints => _iShape_fixpoints.Value;

	private readonly Lazy<Property> _iShape_uuid;
	public Property IShape_uuid => _iShape_uuid.Value;

	private readonly Lazy<Concept> _line;
	public Concept Line => _line.Value;

	private readonly Lazy<Containment> _line_end;
	public Containment Line_end => _line_end.Value;

	private readonly Lazy<Containment> _line_start;
	public Containment Line_start => _line_start.Value;

	private readonly Lazy<Concept> _materialGroup;
	public Concept MaterialGroup => _materialGroup.Value;

	private readonly Lazy<Containment> _materialGroup_defaultShape;
	public Containment MaterialGroup_defaultShape => _materialGroup_defaultShape.Value;

	private readonly Lazy<Reference> _materialGroup_materials;
	public Reference MaterialGroup_materials => _materialGroup_materials.Value;

	private readonly Lazy<Property> _materialGroup_matterState;
	public Property MaterialGroup_matterState => _materialGroup_matterState.Value;

	private readonly Lazy<Enumeration> _matterState;
	public Enumeration MatterState => _matterState.Value;

	private readonly Lazy<EnumerationLiteral> _matterState_gas;
	public EnumerationLiteral MatterState_gas => _matterState_gas.Value;

	private readonly Lazy<EnumerationLiteral> _matterState_liquid;
	public EnumerationLiteral MatterState_liquid => _matterState_liquid.Value;

	private readonly Lazy<EnumerationLiteral> _matterState_solid;
	public EnumerationLiteral MatterState_solid => _matterState_solid.Value;

	private readonly Lazy<Concept> _offsetDuplicate;
	public Concept OffsetDuplicate => _offsetDuplicate.Value;

	private readonly Lazy<Reference> _offsetDuplicate_altSource;
	public Reference OffsetDuplicate_altSource => _offsetDuplicate_altSource.Value;

	private readonly Lazy<Containment> _offsetDuplicate_docs;
	public Containment OffsetDuplicate_docs => _offsetDuplicate_docs.Value;

	private readonly Lazy<Containment> _offsetDuplicate_offset;
	public Containment OffsetDuplicate_offset => _offsetDuplicate_offset.Value;

	private readonly Lazy<Containment> _offsetDuplicate_secretDocs;
	public Containment OffsetDuplicate_secretDocs => _offsetDuplicate_secretDocs.Value;

	private readonly Lazy<Reference> _offsetDuplicate_source;
	public Reference OffsetDuplicate_source => _offsetDuplicate_source.Value;

	private readonly Lazy<Concept> _referenceGeometry;
	public Concept ReferenceGeometry => _referenceGeometry.Value;

	private readonly Lazy<Reference> _referenceGeometry_shapes;
	public Reference ReferenceGeometry_shapes => _referenceGeometry_shapes.Value;

	private readonly Lazy<Concept> _shape;
	public Concept Shape => _shape.Value;

	private readonly Lazy<Containment> _shape_shapeDocs;
	public Containment Shape_shapeDocs => _shape_shapeDocs.Value;

	private readonly Lazy<PrimitiveType> _time;
	public PrimitiveType Time => _time.Value;
}

public partial interface IShapesFactory : INodeFactory
{
	public BillOfMaterials NewBillOfMaterials(string id);
	public BillOfMaterials CreateBillOfMaterials();
	public Circle NewCircle(string id);
	public Circle CreateCircle();
	public CompositeShape NewCompositeShape(string id);
	public CompositeShape CreateCompositeShape();
	public Coord NewCoord(string id);
	public Coord CreateCoord();
	public Documentation NewDocumentation(string id);
	public Documentation CreateDocumentation();
	public Geometry NewGeometry(string id);
	public Geometry CreateGeometry();
	public Line NewLine(string id);
	public Line CreateLine();
	public MaterialGroup NewMaterialGroup(string id);
	public MaterialGroup CreateMaterialGroup();
	public OffsetDuplicate NewOffsetDuplicate(string id);
	public OffsetDuplicate CreateOffsetDuplicate();
	public ReferenceGeometry NewReferenceGeometry(string id);
	public ReferenceGeometry CreateReferenceGeometry();
}

public class ShapesFactory : AbstractBaseNodeFactory, IShapesFactory
{
	private readonly ShapesLanguage _language;
	public ShapesFactory(ShapesLanguage language) : base(language)
	{
		_language = language;
	}

	/// <inheritdoc/>
        public override INode CreateNode(string id, Classifier classifier)
	{
		if (_language.BillOfMaterials.EqualsIdentity(classifier))
			return NewBillOfMaterials(id);
		if (_language.Circle.EqualsIdentity(classifier))
			return NewCircle(id);
		if (_language.CompositeShape.EqualsIdentity(classifier))
			return NewCompositeShape(id);
		if (_language.Coord.EqualsIdentity(classifier))
			return NewCoord(id);
		if (_language.Documentation.EqualsIdentity(classifier))
			return NewDocumentation(id);
		if (_language.Geometry.EqualsIdentity(classifier))
			return NewGeometry(id);
		if (_language.Line.EqualsIdentity(classifier))
			return NewLine(id);
		if (_language.MaterialGroup.EqualsIdentity(classifier))
			return NewMaterialGroup(id);
		if (_language.OffsetDuplicate.EqualsIdentity(classifier))
			return NewOffsetDuplicate(id);
		if (_language.ReferenceGeometry.EqualsIdentity(classifier))
			return NewReferenceGeometry(id);
		throw new UnsupportedClassifierException(classifier);
	}

	/// <inheritdoc/>
        public override Enum GetEnumerationLiteral(EnumerationLiteral literal)
	{
		if (_language.MatterState.EqualsIdentity(literal.GetEnumeration()))
			return EnumValueFor<MatterState>(literal);
		throw new UnsupportedEnumerationLiteralException(literal);
	}

	/// <inheritdoc/>
        public override IStructuredDataTypeInstance CreateStructuredDataTypeInstance(StructuredDataType structuredDataType, IFieldValues fieldValues)
	{
		throw new UnsupportedStructuredDataTypeException(structuredDataType);
	}

	public virtual BillOfMaterials NewBillOfMaterials(string id) => new(id);
	public virtual BillOfMaterials CreateBillOfMaterials() => NewBillOfMaterials(GetNewId());
	public virtual Circle NewCircle(string id) => new(id);
	public virtual Circle CreateCircle() => NewCircle(GetNewId());
	public virtual CompositeShape NewCompositeShape(string id) => new(id);
	public virtual CompositeShape CreateCompositeShape() => NewCompositeShape(GetNewId());
	public virtual Coord NewCoord(string id) => new(id);
	public virtual Coord CreateCoord() => NewCoord(GetNewId());
	public virtual Documentation NewDocumentation(string id) => new(id);
	public virtual Documentation CreateDocumentation() => NewDocumentation(GetNewId());
	public virtual Geometry NewGeometry(string id) => new(id);
	public virtual Geometry CreateGeometry() => NewGeometry(GetNewId());
	public virtual Line NewLine(string id) => new(id);
	public virtual Line CreateLine() => NewLine(GetNewId());
	public virtual MaterialGroup NewMaterialGroup(string id) => new(id);
	public virtual MaterialGroup CreateMaterialGroup() => NewMaterialGroup(GetNewId());
	public virtual OffsetDuplicate NewOffsetDuplicate(string id) => new(id);
	public virtual OffsetDuplicate CreateOffsetDuplicate() => NewOffsetDuplicate(GetNewId());
	public virtual ReferenceGeometry NewReferenceGeometry(string id) => new(id);
	public virtual ReferenceGeometry CreateReferenceGeometry() => NewReferenceGeometry(GetNewId());
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-BillOfMaterials")]
public partial class BillOfMaterials : AnnotationInstanceBase
{
	private bool SetAltGroupsRaw(List<MaterialGroup> nodes) => ExchangeChildrenRaw(nodes, _altGroups);
	private bool AddAltGroupsRaw(MaterialGroup? value) => AddChildRaw(value, _altGroups);
	private bool InsertAltGroupsRaw(int index, MaterialGroup? value) => InsertChildRaw(index, value, _altGroups);
	private bool RemoveAltGroupsRaw(MaterialGroup? value) => RemoveChildRaw(value, _altGroups);
	private readonly List<MaterialGroup> _altGroups = [];
	/// <remarks>Optional Multiple Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-alt-groups")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = true)]
	public IReadOnlyList<MaterialGroup> AltGroups { get => _altGroups.AsReadOnly(); init => AddAltGroups(value); }

	/// <remarks>Optional Multiple Containment</remarks>
        public bool TryGetAltGroups([NotNullWhenAttribute(true)] out IReadOnlyList<MaterialGroup> altGroups)
	{
		altGroups = _altGroups.AsReadOnly();
		return altGroups.Count != 0;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public BillOfMaterials AddAltGroups(IEnumerable<MaterialGroup> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.BillOfMaterials_altGroups);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.BillOfMaterials_altGroups);
		if (_altGroups.SequenceEqual(safeNodes))
			return this;
		foreach (var safeNode in safeNodes)
		{
			ContainmentAddMultipleNotificationEmitter<MaterialGroup> emitter = new(ShapesLanguage.Instance.BillOfMaterials_altGroups, this, safeNode, _altGroups, null);
			emitter.CollectOldData();
			if (AddAltGroupsRaw(safeNode))
				emitter.Notify();
		}

		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public BillOfMaterials InsertAltGroups(int index, IEnumerable<MaterialGroup> nodes)
	{
		AssureInRange(index, _altGroups);
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.BillOfMaterials_altGroups);
		AssureNoSelfMove(index, safeNodes, _altGroups);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.BillOfMaterials_altGroups);
		foreach (var safeNode in safeNodes)
		{
			ContainmentAddMultipleNotificationEmitter<MaterialGroup> emitter = new(ShapesLanguage.Instance.BillOfMaterials_altGroups, this, safeNode, _altGroups, index);
			emitter.CollectOldData();
			if (InsertAltGroupsRaw(index++, safeNode))
				emitter.Notify();
		}

		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public BillOfMaterials RemoveAltGroups(IEnumerable<MaterialGroup> nodes)
	{
		RemoveSelfParent(nodes?.ToList(), _altGroups, ShapesLanguage.Instance.BillOfMaterials_altGroups, ContainmentRemover<MaterialGroup>(ShapesLanguage.Instance.BillOfMaterials_altGroups));
		return this;
	}

	private MaterialGroup? _defaultGroup = null;
	/// <remarks>Optional Single Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-default-group")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = false)]
	public MaterialGroup? DefaultGroup { get => _defaultGroup; set => SetDefaultGroup(value); }

	/// <remarks>Optional Single Containment</remarks>
        public bool TryGetDefaultGroup([NotNullWhenAttribute(true)] out MaterialGroup? defaultGroup)
	{
		defaultGroup = _defaultGroup;
		return defaultGroup != null;
	}

	private bool SetDefaultGroupRaw(MaterialGroup? value)
	{
		if (!ExchangeChildRaw(value, _defaultGroup))
			return false;
		_defaultGroup = value;
		return true;
	}

	/// <remarks>Optional Single Containment</remarks>
        public BillOfMaterials SetDefaultGroup(MaterialGroup? value)
	{
		ContainmentSingleNotificationEmitter<MaterialGroup> emitter = new(ShapesLanguage.Instance.BillOfMaterials_defaultGroup, this, value, _defaultGroup);
		emitter.CollectOldData();
		if (SetDefaultGroupRaw(value))
			emitter.Notify();
		return this;
	}

	private bool SetGroupsRaw(List<MaterialGroup> nodes) => ExchangeChildrenRaw(nodes, _groups);
	private bool AddGroupsRaw(MaterialGroup? value) => AddChildRaw(value, _groups);
	private bool InsertGroupsRaw(int index, MaterialGroup? value) => InsertChildRaw(index, value, _groups);
	private bool RemoveGroupsRaw(MaterialGroup? value) => RemoveChildRaw(value, _groups);
	private readonly List<MaterialGroup> _groups = [];
	/// <remarks>Optional Multiple Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-groups")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = true)]
	public IReadOnlyList<MaterialGroup> Groups { get => _groups.AsReadOnly(); init => AddGroups(value); }

	/// <remarks>Optional Multiple Containment</remarks>
        public bool TryGetGroups([NotNullWhenAttribute(true)] out IReadOnlyList<MaterialGroup> groups)
	{
		groups = _groups.AsReadOnly();
		return groups.Count != 0;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public BillOfMaterials AddGroups(IEnumerable<MaterialGroup> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.BillOfMaterials_groups);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.BillOfMaterials_groups);
		if (_groups.SequenceEqual(safeNodes))
			return this;
		foreach (var safeNode in safeNodes)
		{
			ContainmentAddMultipleNotificationEmitter<MaterialGroup> emitter = new(ShapesLanguage.Instance.BillOfMaterials_groups, this, safeNode, _groups, null);
			emitter.CollectOldData();
			if (AddGroupsRaw(safeNode))
				emitter.Notify();
		}

		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public BillOfMaterials InsertGroups(int index, IEnumerable<MaterialGroup> nodes)
	{
		AssureInRange(index, _groups);
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.BillOfMaterials_groups);
		AssureNoSelfMove(index, safeNodes, _groups);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.BillOfMaterials_groups);
		foreach (var safeNode in safeNodes)
		{
			ContainmentAddMultipleNotificationEmitter<MaterialGroup> emitter = new(ShapesLanguage.Instance.BillOfMaterials_groups, this, safeNode, _groups, index);
			emitter.CollectOldData();
			if (InsertGroupsRaw(index++, safeNode))
				emitter.Notify();
		}

		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public BillOfMaterials RemoveGroups(IEnumerable<MaterialGroup> nodes)
	{
		RemoveSelfParent(nodes?.ToList(), _groups, ShapesLanguage.Instance.BillOfMaterials_groups, ContainmentRemover<MaterialGroup>(ShapesLanguage.Instance.BillOfMaterials_groups));
		return this;
	}

	private readonly List<ReferenceTarget> _materials = [];
	/// <remarks>Optional Multiple Reference</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-materials")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = true, Multiple = true)]
	public IReadOnlyList<IShape> Materials { get => ReferenceTargetNonNullTargets<IShape>(_materials, ShapesLanguage.Instance.BillOfMaterials_materials); init => AddMaterials(value); }

	/// <remarks>Optional Multiple Reference</remarks>
        public bool TryGetMaterials([NotNullWhenAttribute(true)] out IReadOnlyList<IShape> materials) => TryGetReference<IShape>(_materials, out materials);
	private bool SetMaterialsRaw(List<ReferenceTarget> targets)
	{
		if (_materials.SequenceEqual(targets))
			return false;
		_materials.Clear();
		_materials.AddRange(targets);
		return true;
	}

	private bool AddMaterialsRaw(ReferenceTarget? target)
	{
		if (target is null)
			return false;
		_materials.Add(target);
		return true;
	}

	private bool InsertMaterialsRaw(int index, ReferenceTarget? target)
	{
		if (target is null || !IsInRange(index, _materials))
			return false;
		_materials.Insert(index, target);
		return true;
	}

	private bool RemoveMaterialsRaw(ReferenceTarget? target) => Remove(target, _materials);
	/// <remarks>Optional Multiple Reference</remarks>
        public BillOfMaterials AddMaterials(IEnumerable<IShape> nodes)
	{
		var safeNodes = nodes?.Select(ReferenceTarget.FromNode).ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.BillOfMaterials_materials);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.BillOfMaterials_materials);
		ReferenceAddMultipleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.BillOfMaterials_materials, this, safeNodes, _materials.Count);
		emitter.CollectOldData();
		_materials.AddRange(safeNodes);
		emitter.Notify();
		return this;
	}

	/// <remarks>Optional Multiple Reference</remarks>
        public BillOfMaterials InsertMaterials(int index, IEnumerable<IShape> nodes)
	{
		AssureInRange(index, _materials);
		var safeNodes = nodes?.Select(ReferenceTarget.FromNode).ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.BillOfMaterials_materials);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.BillOfMaterials_materials);
		ReferenceAddMultipleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.BillOfMaterials_materials, this, safeNodes, index);
		emitter.CollectOldData();
		_materials.InsertRange(index, safeNodes);
		emitter.Notify();
		return this;
	}

	/// <remarks>Optional Multiple Reference</remarks>
        public BillOfMaterials RemoveMaterials(IEnumerable<IShape> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.BillOfMaterials_materials);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.BillOfMaterials_materials);
		RemoveAll(safeNodes, _materials, ReferenceRemover<IShape>(ShapesLanguage.Instance.BillOfMaterials_materials));
		return this;
	}

	public BillOfMaterials(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Annotation GetAnnotation() => ShapesLanguage.Instance.BillOfMaterials;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_altGroups.EqualsIdentity(feature))
		{
			result = AltGroups;
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_defaultGroup.EqualsIdentity(feature))
		{
			result = DefaultGroup;
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_groups.EqualsIdentity(feature))
		{
			result = Groups;
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_materials.EqualsIdentity(feature))
		{
			result = Materials;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetContainmentRaw(Containment feature, out IReadableNode? result)
	{
		if (base.TryGetContainmentRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_defaultGroup.EqualsIdentity(feature))
		{
			result = _defaultGroup;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetContainmentsRaw(Containment feature, out IReadOnlyList<IReadableNode> result)
	{
		if (base.TryGetContainmentsRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_altGroups.EqualsIdentity(feature))
		{
			result = _altGroups;
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_groups.EqualsIdentity(feature))
		{
			result = _groups;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetReferencesRaw(Reference feature, out IReadOnlyList<IReferenceTarget> result)
	{
		if (base.TryGetReferencesRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_materials.EqualsIdentity(feature))
		{
			result = _materials;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_altGroups.EqualsIdentity(feature))
		{
			var safeNodes = ShapesLanguage.Instance.BillOfMaterials_altGroups.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup>(value).ToList();
			ContainmentSetNotificationEmitter<MaterialGroup> emitter = new(ShapesLanguage.Instance.BillOfMaterials_altGroups, this, safeNodes, _altGroups);
			emitter.CollectOldData();
			if (SetAltGroupsRaw(safeNodes))
				emitter.Notify();
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_defaultGroup.EqualsIdentity(feature))
		{
			if (value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup)
			{
				SetDefaultGroup((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup?)value);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.BillOfMaterials_groups.EqualsIdentity(feature))
		{
			var safeNodes = ShapesLanguage.Instance.BillOfMaterials_groups.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup>(value).ToList();
			ContainmentSetNotificationEmitter<MaterialGroup> emitter = new(ShapesLanguage.Instance.BillOfMaterials_groups, this, safeNodes, _groups);
			emitter.CollectOldData();
			if (SetGroupsRaw(safeNodes))
				emitter.Notify();
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_materials.EqualsIdentity(feature))
		{
			var safeNodes = ShapesLanguage.Instance.BillOfMaterials_materials.AsReferenceTargets<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value).ToList();
			AssureNotNull(safeNodes, ShapesLanguage.Instance.BillOfMaterials_materials);
			AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.BillOfMaterials_materials);
			ReferenceSetNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.BillOfMaterials_materials, this, safeNodes, _materials);
			emitter.CollectOldData();
			if (SetMaterialsRaw(safeNodes))
				emitter.Notify();
			return true;
		}

		return false;
	}

	protected internal override bool SetContainmentRaw(Containment feature, IWritableNode? value)
	{
		if (base.SetContainmentRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_defaultGroup.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup)
			return SetDefaultGroupRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetAltGroups(out _))
			result.Add(ShapesLanguage.Instance.BillOfMaterials_altGroups);
		if (TryGetDefaultGroup(out _))
			result.Add(ShapesLanguage.Instance.BillOfMaterials_defaultGroup);
		if (TryGetGroups(out _))
			result.Add(ShapesLanguage.Instance.BillOfMaterials_groups);
		if (TryGetMaterials(out _))
			result.Add(ShapesLanguage.Instance.BillOfMaterials_materials);
		return result;
	}

	protected internal override bool AddContainmentsRaw(Containment feature, IWritableNode? value)
	{
		if (base.AddContainmentsRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_altGroups.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup)
			return AddAltGroupsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup?)value);
		if (ShapesLanguage.Instance.BillOfMaterials_groups.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup)
			return AddGroupsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup?)value);
		return false;
	}

	protected internal override bool AddReferencesRaw(Reference feature, ReferenceTarget? value)
	{
		if (base.AddReferencesRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_materials.EqualsIdentity(feature))
			return AddMaterialsRaw(value);
		return false;
	}

	protected internal override bool InsertContainmentsRaw(Containment feature, int index, IWritableNode? value)
	{
		if (base.InsertContainmentsRaw(feature, index, value))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_altGroups.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup)
			return InsertAltGroupsRaw(index, (LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup?)value);
		if (ShapesLanguage.Instance.BillOfMaterials_groups.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup)
			return InsertGroupsRaw(index, (LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup?)value);
		return false;
	}

	protected internal override bool InsertReferencesRaw(Reference feature, int index, ReferenceTarget? value)
	{
		if (base.InsertReferencesRaw(feature, index, value))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_materials.EqualsIdentity(feature))
			return InsertMaterialsRaw(index, value);
		return false;
	}

	protected internal override bool RemoveContainmentsRaw(Containment feature, IWritableNode? value)
	{
		if (base.RemoveContainmentsRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_altGroups.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup)
			return RemoveAltGroupsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup?)value);
		if (ShapesLanguage.Instance.BillOfMaterials_groups.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup)
			return RemoveGroupsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup?)value);
		return false;
	}

	protected internal override bool RemoveReferencesRaw(Reference feature, ReferenceTarget? value)
	{
		if (base.RemoveReferencesRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_materials.EqualsIdentity(feature))
			return RemoveMaterialsRaw(value);
		return false;
	}

	/// <inheritdoc/>
        protected override bool AddInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.AddInternal(link, value))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_altGroups.EqualsIdentity(link))
		{
			AddAltGroups(ShapesLanguage.Instance.BillOfMaterials_altGroups.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup>(value));
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_groups.EqualsIdentity(link))
		{
			AddGroups(ShapesLanguage.Instance.BillOfMaterials_groups.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup>(value));
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_materials.EqualsIdentity(link))
		{
			AddMaterials(ShapesLanguage.Instance.BillOfMaterials_materials.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool InsertInternal(Link? link, int index, IEnumerable<IReadableNode> value)
	{
		if (base.InsertInternal(link, index, value))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_altGroups.EqualsIdentity(link))
		{
			InsertAltGroups(index, ShapesLanguage.Instance.BillOfMaterials_altGroups.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup>(value));
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_groups.EqualsIdentity(link))
		{
			InsertGroups(index, ShapesLanguage.Instance.BillOfMaterials_groups.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup>(value));
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_materials.EqualsIdentity(link))
		{
			InsertMaterials(index, ShapesLanguage.Instance.BillOfMaterials_materials.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool RemoveInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.RemoveInternal(link, value))
			return true;
		if (ShapesLanguage.Instance.BillOfMaterials_altGroups.EqualsIdentity(link))
		{
			RemoveAltGroups(ShapesLanguage.Instance.BillOfMaterials_altGroups.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup>(value));
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_groups.EqualsIdentity(link))
		{
			RemoveGroups(ShapesLanguage.Instance.BillOfMaterials_groups.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MaterialGroup>(value));
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_materials.EqualsIdentity(link))
		{
			RemoveMaterials(ShapesLanguage.Instance.BillOfMaterials_materials.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (ShapesLanguage.Instance.BillOfMaterials_altGroups.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _altGroups, ShapesLanguage.Instance.BillOfMaterials_altGroups);
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_defaultGroup.EqualsIdentity(c))
		{
			_defaultGroup = null;
			return true;
		}

		if (ShapesLanguage.Instance.BillOfMaterials_groups.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _groups, ShapesLanguage.Instance.BillOfMaterials_groups);
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (child is MaterialGroup child0 && _altGroups.Contains(child0))
			return ShapesLanguage.Instance.BillOfMaterials_altGroups;
		if (ReferenceEquals(_defaultGroup, child))
			return ShapesLanguage.Instance.BillOfMaterials_defaultGroup;
		if (child is MaterialGroup child2 && _groups.Contains(child2))
			return ShapesLanguage.Instance.BillOfMaterials_groups;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-Circle")]
public partial class Circle : Shape
{
	private Coord? _center = null;
	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If Center has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-center")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = false)]
	public Coord Center { get => _center ?? throw new UnsetFeatureException(ShapesLanguage.Instance.Circle_center); set => SetCenter(value); }

	/// <remarks>Required Single Containment</remarks>
        public bool TryGetCenter([NotNullWhenAttribute(true)] out Coord? center)
	{
		center = _center;
		return center != null;
	}

	private bool SetCenterRaw(Coord? value)
	{
		if (!ExchangeChildRaw(value, _center))
			return false;
		_center = value;
		return true;
	}

	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public Circle SetCenter(Coord value)
	{
		AssureNotNull(value, ShapesLanguage.Instance.Circle_center);
		ContainmentSingleNotificationEmitter<Coord> emitter = new(ShapesLanguage.Instance.Circle_center, this, value, _center);
		emitter.CollectOldData();
		if (SetCenterRaw(value))
			emitter.Notify();
		return this;
	}

	private int? _r = null;
	private bool SetRRaw(int? value)
	{
		if (value == _r)
			return false;
		_r = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If R has not been set</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-r")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public int R { get => _r ?? throw new UnsetFeatureException(ShapesLanguage.Instance.Circle_r); set => SetR(value); }

	/// <remarks>Required Property</remarks>
        public bool TryGetR([NotNullWhenAttribute(true)] out int? r)
	{
		r = _r;
		return r != null;
	}

	/// <remarks>Required Property</remarks>
        public Circle SetR(int value)
	{
		PropertyNotificationEmitter emitter = new(ShapesLanguage.Instance.Circle_r, this, value, _r);
		emitter.CollectOldData();
		if (SetRRaw(value))
			emitter.Notify();
		return this;
	}

	public Circle(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => ShapesLanguage.Instance.Circle;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Circle_center.EqualsIdentity(feature))
		{
			result = Center;
			return true;
		}

		if (ShapesLanguage.Instance.Circle_r.EqualsIdentity(feature))
		{
			result = R;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Circle_r.EqualsIdentity(feature))
		{
			result = _r;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetContainmentRaw(Containment feature, out IReadableNode? result)
	{
		if (base.TryGetContainmentRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Circle_center.EqualsIdentity(feature))
		{
			result = _center;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (ShapesLanguage.Instance.Circle_center.EqualsIdentity(feature))
		{
			if (value is LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord v)
			{
				SetCenter(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.Circle_r.EqualsIdentity(feature))
		{
			if (value is int v)
			{
				SetR(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected internal override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.Circle_r.EqualsIdentity(feature) && value is null or int)
			return SetRRaw((int?)value);
		return false;
	}

	protected internal override bool SetContainmentRaw(Containment feature, IWritableNode? value)
	{
		if (base.SetContainmentRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.Circle_center.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord)
			return SetCenterRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetCenter(out _))
			result.Add(ShapesLanguage.Instance.Circle_center);
		if (TryGetR(out _))
			result.Add(ShapesLanguage.Instance.Circle_r);
		return result;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (ShapesLanguage.Instance.Circle_center.EqualsIdentity(c))
		{
			_center = null;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (ReferenceEquals(_center, child))
			return ShapesLanguage.Instance.Circle_center;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-CompositeShape")]
public partial class CompositeShape : Shape
{
	private bool SetDisabledPartsRaw(List<IShape> nodes) => ExchangeChildrenRaw(nodes, _disabledParts);
	private bool AddDisabledPartsRaw(IShape? value) => AddChildRaw(value, _disabledParts);
	private bool InsertDisabledPartsRaw(int index, IShape? value) => InsertChildRaw(index, value, _disabledParts);
	private bool RemoveDisabledPartsRaw(IShape? value) => RemoveChildRaw(value, _disabledParts);
	private readonly List<IShape> _disabledParts = [];
	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If DisabledParts is empty</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-disabled-parts")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = true)]
	public IReadOnlyList<IShape> DisabledParts { get => AsNonEmptyReadOnly(_disabledParts, ShapesLanguage.Instance.CompositeShape_disabledParts); init => AddDisabledParts(value); }

	/// <remarks>Required Multiple Containment</remarks>
        public bool TryGetDisabledParts([NotNullWhenAttribute(true)] out IReadOnlyList<IShape> disabledParts)
	{
		disabledParts = _disabledParts.AsReadOnly();
		return disabledParts.Count != 0;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If both DisabledParts and nodes are empty</exception>
        public CompositeShape AddDisabledParts(IEnumerable<IShape> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNonEmpty(safeNodes, _disabledParts, ShapesLanguage.Instance.CompositeShape_disabledParts);
		if (_disabledParts.SequenceEqual(safeNodes))
			return this;
		foreach (var safeNode in safeNodes)
		{
			ContainmentAddMultipleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.CompositeShape_disabledParts, this, safeNode, _disabledParts, null);
			emitter.CollectOldData();
			if (AddDisabledPartsRaw(safeNode))
				emitter.Notify();
		}

		return this;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If both DisabledParts and nodes are empty</exception>
    	/// <exception cref = "ArgumentOutOfRangeException">If index negative or greater than DisabledParts.Count</exception>
        public CompositeShape InsertDisabledParts(int index, IEnumerable<IShape> nodes)
	{
		AssureInRange(index, _disabledParts);
		var safeNodes = nodes?.ToList();
		AssureNonEmpty(safeNodes, _disabledParts, ShapesLanguage.Instance.CompositeShape_disabledParts);
		AssureNoSelfMove(index, safeNodes, _disabledParts);
		foreach (var safeNode in safeNodes)
		{
			ContainmentAddMultipleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.CompositeShape_disabledParts, this, safeNode, _disabledParts, index);
			emitter.CollectOldData();
			if (InsertDisabledPartsRaw(index++, safeNode))
				emitter.Notify();
		}

		return this;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If DisabledParts would be empty</exception>
        public CompositeShape RemoveDisabledParts(IEnumerable<IShape> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.CompositeShape_disabledParts);
		AssureNotClearing(safeNodes, _disabledParts, ShapesLanguage.Instance.CompositeShape_disabledParts);
		RemoveSelfParent(safeNodes, _disabledParts, ShapesLanguage.Instance.CompositeShape_disabledParts, ContainmentRemover<IShape>(ShapesLanguage.Instance.CompositeShape_disabledParts));
		return this;
	}

	private IShape? _evilPart = null;
	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If EvilPart has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-evil-part")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = false)]
	public IShape EvilPart { get => _evilPart ?? throw new UnsetFeatureException(ShapesLanguage.Instance.CompositeShape_evilPart); set => SetEvilPart(value); }

	/// <remarks>Required Single Containment</remarks>
        public bool TryGetEvilPart([NotNullWhenAttribute(true)] out IShape? evilPart)
	{
		evilPart = _evilPart;
		return evilPart != null;
	}

	private bool SetEvilPartRaw(IShape? value)
	{
		if (!ExchangeChildRaw(value, _evilPart))
			return false;
		_evilPart = value;
		return true;
	}

	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public CompositeShape SetEvilPart(IShape value)
	{
		AssureNotNull(value, ShapesLanguage.Instance.CompositeShape_evilPart);
		ContainmentSingleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.CompositeShape_evilPart, this, value, _evilPart);
		emitter.CollectOldData();
		if (SetEvilPartRaw(value))
			emitter.Notify();
		return this;
	}

	private bool SetPartsRaw(List<IShape> nodes) => ExchangeChildrenRaw(nodes, _parts);
	private bool AddPartsRaw(IShape? value) => AddChildRaw(value, _parts);
	private bool InsertPartsRaw(int index, IShape? value) => InsertChildRaw(index, value, _parts);
	private bool RemovePartsRaw(IShape? value) => RemoveChildRaw(value, _parts);
	private readonly List<IShape> _parts = [];
	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If Parts is empty</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-parts")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = true)]
	public IReadOnlyList<IShape> Parts { get => AsNonEmptyReadOnly(_parts, ShapesLanguage.Instance.CompositeShape_parts); init => AddParts(value); }

	/// <remarks>Required Multiple Containment</remarks>
        public bool TryGetParts([NotNullWhenAttribute(true)] out IReadOnlyList<IShape> parts)
	{
		parts = _parts.AsReadOnly();
		return parts.Count != 0;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If both Parts and nodes are empty</exception>
        public CompositeShape AddParts(IEnumerable<IShape> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNonEmpty(safeNodes, _parts, ShapesLanguage.Instance.CompositeShape_parts);
		if (_parts.SequenceEqual(safeNodes))
			return this;
		foreach (var safeNode in safeNodes)
		{
			ContainmentAddMultipleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.CompositeShape_parts, this, safeNode, _parts, null);
			emitter.CollectOldData();
			if (AddPartsRaw(safeNode))
				emitter.Notify();
		}

		return this;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If both Parts and nodes are empty</exception>
    	/// <exception cref = "ArgumentOutOfRangeException">If index negative or greater than Parts.Count</exception>
        public CompositeShape InsertParts(int index, IEnumerable<IShape> nodes)
	{
		AssureInRange(index, _parts);
		var safeNodes = nodes?.ToList();
		AssureNonEmpty(safeNodes, _parts, ShapesLanguage.Instance.CompositeShape_parts);
		AssureNoSelfMove(index, safeNodes, _parts);
		foreach (var safeNode in safeNodes)
		{
			ContainmentAddMultipleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.CompositeShape_parts, this, safeNode, _parts, index);
			emitter.CollectOldData();
			if (InsertPartsRaw(index++, safeNode))
				emitter.Notify();
		}

		return this;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If Parts would be empty</exception>
        public CompositeShape RemoveParts(IEnumerable<IShape> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.CompositeShape_parts);
		AssureNotClearing(safeNodes, _parts, ShapesLanguage.Instance.CompositeShape_parts);
		RemoveSelfParent(safeNodes, _parts, ShapesLanguage.Instance.CompositeShape_parts, ContainmentRemover<IShape>(ShapesLanguage.Instance.CompositeShape_parts));
		return this;
	}

	public CompositeShape(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => ShapesLanguage.Instance.CompositeShape;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (ShapesLanguage.Instance.CompositeShape_disabledParts.EqualsIdentity(feature))
		{
			result = DisabledParts;
			return true;
		}

		if (ShapesLanguage.Instance.CompositeShape_evilPart.EqualsIdentity(feature))
		{
			result = EvilPart;
			return true;
		}

		if (ShapesLanguage.Instance.CompositeShape_parts.EqualsIdentity(feature))
		{
			result = Parts;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetContainmentRaw(Containment feature, out IReadableNode? result)
	{
		if (base.TryGetContainmentRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.CompositeShape_evilPart.EqualsIdentity(feature))
		{
			result = _evilPart;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetContainmentsRaw(Containment feature, out IReadOnlyList<IReadableNode> result)
	{
		if (base.TryGetContainmentsRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.CompositeShape_disabledParts.EqualsIdentity(feature))
		{
			result = _disabledParts;
			return true;
		}

		if (ShapesLanguage.Instance.CompositeShape_parts.EqualsIdentity(feature))
		{
			result = _parts;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (ShapesLanguage.Instance.CompositeShape_disabledParts.EqualsIdentity(feature))
		{
			var safeNodes = ShapesLanguage.Instance.CompositeShape_disabledParts.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value).ToList();
			AssureNonEmpty(safeNodes, ShapesLanguage.Instance.CompositeShape_disabledParts);
			ContainmentSetNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.CompositeShape_disabledParts, this, safeNodes, _disabledParts);
			emitter.CollectOldData();
			if (SetDisabledPartsRaw(safeNodes))
				emitter.Notify();
			return true;
		}

		if (ShapesLanguage.Instance.CompositeShape_evilPart.EqualsIdentity(feature))
		{
			if (value is LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape v)
			{
				SetEvilPart(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.CompositeShape_parts.EqualsIdentity(feature))
		{
			var safeNodes = ShapesLanguage.Instance.CompositeShape_parts.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value).ToList();
			AssureNonEmpty(safeNodes, ShapesLanguage.Instance.CompositeShape_parts);
			ContainmentSetNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.CompositeShape_parts, this, safeNodes, _parts);
			emitter.CollectOldData();
			if (SetPartsRaw(safeNodes))
				emitter.Notify();
			return true;
		}

		return false;
	}

	protected internal override bool SetContainmentRaw(Containment feature, IWritableNode? value)
	{
		if (base.SetContainmentRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.CompositeShape_evilPart.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape)
			return SetEvilPartRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetDisabledParts(out _))
			result.Add(ShapesLanguage.Instance.CompositeShape_disabledParts);
		if (TryGetEvilPart(out _))
			result.Add(ShapesLanguage.Instance.CompositeShape_evilPart);
		if (TryGetParts(out _))
			result.Add(ShapesLanguage.Instance.CompositeShape_parts);
		return result;
	}

	protected internal override bool AddContainmentsRaw(Containment feature, IWritableNode? value)
	{
		if (base.AddContainmentsRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.CompositeShape_disabledParts.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape)
			return AddDisabledPartsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape?)value);
		if (ShapesLanguage.Instance.CompositeShape_parts.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape)
			return AddPartsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape?)value);
		return false;
	}

	protected internal override bool InsertContainmentsRaw(Containment feature, int index, IWritableNode? value)
	{
		if (base.InsertContainmentsRaw(feature, index, value))
			return true;
		if (ShapesLanguage.Instance.CompositeShape_disabledParts.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape)
			return InsertDisabledPartsRaw(index, (LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape?)value);
		if (ShapesLanguage.Instance.CompositeShape_parts.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape)
			return InsertPartsRaw(index, (LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape?)value);
		return false;
	}

	protected internal override bool RemoveContainmentsRaw(Containment feature, IWritableNode? value)
	{
		if (base.RemoveContainmentsRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.CompositeShape_disabledParts.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape)
			return RemoveDisabledPartsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape?)value);
		if (ShapesLanguage.Instance.CompositeShape_parts.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape)
			return RemovePartsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape?)value);
		return false;
	}

	/// <inheritdoc/>
        protected override bool AddInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.AddInternal(link, value))
			return true;
		if (ShapesLanguage.Instance.CompositeShape_disabledParts.EqualsIdentity(link))
		{
			AddDisabledParts(ShapesLanguage.Instance.CompositeShape_disabledParts.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		if (ShapesLanguage.Instance.CompositeShape_parts.EqualsIdentity(link))
		{
			AddParts(ShapesLanguage.Instance.CompositeShape_parts.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool InsertInternal(Link? link, int index, IEnumerable<IReadableNode> value)
	{
		if (base.InsertInternal(link, index, value))
			return true;
		if (ShapesLanguage.Instance.CompositeShape_disabledParts.EqualsIdentity(link))
		{
			InsertDisabledParts(index, ShapesLanguage.Instance.CompositeShape_disabledParts.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		if (ShapesLanguage.Instance.CompositeShape_parts.EqualsIdentity(link))
		{
			InsertParts(index, ShapesLanguage.Instance.CompositeShape_parts.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool RemoveInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.RemoveInternal(link, value))
			return true;
		if (ShapesLanguage.Instance.CompositeShape_disabledParts.EqualsIdentity(link))
		{
			RemoveDisabledParts(ShapesLanguage.Instance.CompositeShape_disabledParts.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		if (ShapesLanguage.Instance.CompositeShape_parts.EqualsIdentity(link))
		{
			RemoveParts(ShapesLanguage.Instance.CompositeShape_parts.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (ShapesLanguage.Instance.CompositeShape_disabledParts.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _disabledParts, ShapesLanguage.Instance.CompositeShape_disabledParts);
			return true;
		}

		if (ShapesLanguage.Instance.CompositeShape_evilPart.EqualsIdentity(c))
		{
			_evilPart = null;
			return true;
		}

		if (ShapesLanguage.Instance.CompositeShape_parts.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _parts, ShapesLanguage.Instance.CompositeShape_parts);
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (child is IShape child0 && _disabledParts.Contains(child0))
			return ShapesLanguage.Instance.CompositeShape_disabledParts;
		if (ReferenceEquals(_evilPart, child))
			return ShapesLanguage.Instance.CompositeShape_evilPart;
		if (child is IShape child2 && _parts.Contains(child2))
			return ShapesLanguage.Instance.CompositeShape_parts;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-Coord")]
public partial class Coord : ConceptInstanceBase
{
	private int? _x = null;
	private bool SetXRaw(int? value)
	{
		if (value == _x)
			return false;
		_x = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If X has not been set</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-x")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public int X { get => _x ?? throw new UnsetFeatureException(ShapesLanguage.Instance.Coord_x); set => SetX(value); }

	/// <remarks>Required Property</remarks>
        public bool TryGetX([NotNullWhenAttribute(true)] out int? x)
	{
		x = _x;
		return x != null;
	}

	/// <remarks>Required Property</remarks>
        public Coord SetX(int value)
	{
		PropertyNotificationEmitter emitter = new(ShapesLanguage.Instance.Coord_x, this, value, _x);
		emitter.CollectOldData();
		if (SetXRaw(value))
			emitter.Notify();
		return this;
	}

	private int? _y = null;
	private bool SetYRaw(int? value)
	{
		if (value == _y)
			return false;
		_y = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If Y has not been set</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-y")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public int Y { get => _y ?? throw new UnsetFeatureException(ShapesLanguage.Instance.Coord_y); set => SetY(value); }

	/// <remarks>Required Property</remarks>
        public bool TryGetY([NotNullWhenAttribute(true)] out int? y)
	{
		y = _y;
		return y != null;
	}

	/// <remarks>Required Property</remarks>
        public Coord SetY(int value)
	{
		PropertyNotificationEmitter emitter = new(ShapesLanguage.Instance.Coord_y, this, value, _y);
		emitter.CollectOldData();
		if (SetYRaw(value))
			emitter.Notify();
		return this;
	}

	private int? _z = null;
	private bool SetZRaw(int? value)
	{
		if (value == _z)
			return false;
		_z = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If Z has not been set</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-z")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public int Z { get => _z ?? throw new UnsetFeatureException(ShapesLanguage.Instance.Coord_z); set => SetZ(value); }

	/// <remarks>Required Property</remarks>
        public bool TryGetZ([NotNullWhenAttribute(true)] out int? z)
	{
		z = _z;
		return z != null;
	}

	/// <remarks>Required Property</remarks>
        public Coord SetZ(int value)
	{
		PropertyNotificationEmitter emitter = new(ShapesLanguage.Instance.Coord_z, this, value, _z);
		emitter.CollectOldData();
		if (SetZRaw(value))
			emitter.Notify();
		return this;
	}

	public Coord(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => ShapesLanguage.Instance.Coord;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Coord_x.EqualsIdentity(feature))
		{
			result = X;
			return true;
		}

		if (ShapesLanguage.Instance.Coord_y.EqualsIdentity(feature))
		{
			result = Y;
			return true;
		}

		if (ShapesLanguage.Instance.Coord_z.EqualsIdentity(feature))
		{
			result = Z;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Coord_x.EqualsIdentity(feature))
		{
			result = _x;
			return true;
		}

		if (ShapesLanguage.Instance.Coord_y.EqualsIdentity(feature))
		{
			result = _y;
			return true;
		}

		if (ShapesLanguage.Instance.Coord_z.EqualsIdentity(feature))
		{
			result = _z;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (ShapesLanguage.Instance.Coord_x.EqualsIdentity(feature))
		{
			if (value is int v)
			{
				SetX(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.Coord_y.EqualsIdentity(feature))
		{
			if (value is int v)
			{
				SetY(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.Coord_z.EqualsIdentity(feature))
		{
			if (value is int v)
			{
				SetZ(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected internal override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.Coord_x.EqualsIdentity(feature) && value is null or int)
			return SetXRaw((int?)value);
		if (ShapesLanguage.Instance.Coord_y.EqualsIdentity(feature) && value is null or int)
			return SetYRaw((int?)value);
		if (ShapesLanguage.Instance.Coord_z.EqualsIdentity(feature) && value is null or int)
			return SetZRaw((int?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetX(out _))
			result.Add(ShapesLanguage.Instance.Coord_x);
		if (TryGetY(out _))
			result.Add(ShapesLanguage.Instance.Coord_y);
		if (TryGetZ(out _))
			result.Add(ShapesLanguage.Instance.Coord_z);
		return result;
	}
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-Documentation")]
public partial class Documentation : AnnotationInstanceBase
{
	private bool? _technical = null;
	/// <remarks>Optional Property</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-technical")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = true, Multiple = false)]
	public bool? Technical { get => _technical; set => SetTechnical(value); }

	/// <remarks>Optional Property</remarks>
        public bool TryGetTechnical([NotNullWhenAttribute(true)] out bool? technical)
	{
		technical = _technical;
		return technical != null;
	}

	private bool SetTechnicalRaw(bool? value)
	{
		if (value == _technical)
			return false;
		_technical = value;
		return true;
	}

	/// <remarks>Optional Property</remarks>
        public Documentation SetTechnical(bool? value)
	{
		PropertyNotificationEmitter emitter = new(ShapesLanguage.Instance.Documentation_technical, this, value, _technical);
		emitter.CollectOldData();
		if (SetTechnicalRaw(value))
			emitter.Notify();
		return this;
	}

	private string? _text = null;
	/// <remarks>Optional Property</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-text")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = true, Multiple = false)]
	public string? Text { get => _text; set => SetText(value); }

	/// <remarks>Optional Property</remarks>
        public bool TryGetText([NotNullWhenAttribute(true)] out string? text)
	{
		text = _text;
		return text != null;
	}

	private bool SetTextRaw(string? value)
	{
		if (value == _text)
			return false;
		_text = value;
		return true;
	}

	/// <remarks>Optional Property</remarks>
        public Documentation SetText(string? value)
	{
		PropertyNotificationEmitter emitter = new(ShapesLanguage.Instance.Documentation_text, this, value, _text);
		emitter.CollectOldData();
		if (SetTextRaw(value))
			emitter.Notify();
		return this;
	}

	public Documentation(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Annotation GetAnnotation() => ShapesLanguage.Instance.Documentation;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Documentation_technical.EqualsIdentity(feature))
		{
			result = Technical;
			return true;
		}

		if (ShapesLanguage.Instance.Documentation_text.EqualsIdentity(feature))
		{
			result = Text;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Documentation_technical.EqualsIdentity(feature))
		{
			result = _technical;
			return true;
		}

		if (ShapesLanguage.Instance.Documentation_text.EqualsIdentity(feature))
		{
			result = _text;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (ShapesLanguage.Instance.Documentation_technical.EqualsIdentity(feature))
		{
			if (value is null or bool)
			{
				SetTechnical((bool?)value);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.Documentation_text.EqualsIdentity(feature))
		{
			if (value is null or string)
			{
				SetText((string?)value);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected internal override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.Documentation_technical.EqualsIdentity(feature) && value is null or bool)
			return SetTechnicalRaw((bool?)value);
		if (ShapesLanguage.Instance.Documentation_text.EqualsIdentity(feature) && value is null or string)
			return SetTextRaw((string?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetTechnical(out _))
			result.Add(ShapesLanguage.Instance.Documentation_technical);
		if (TryGetText(out _))
			result.Add(ShapesLanguage.Instance.Documentation_text);
		return result;
	}
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-Geometry")]
public partial class Geometry : ConceptInstanceBase, IPartitionInstance<INode>
{
	private Documentation? _documentation = null;
	/// <remarks>Optional Single Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-documentation")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = false)]
	public Documentation? Documentation { get => _documentation; set => SetDocumentation(value); }

	/// <remarks>Optional Single Containment</remarks>
        public bool TryGetDocumentation([NotNullWhenAttribute(true)] out Documentation? documentation)
	{
		documentation = _documentation;
		return documentation != null;
	}

	private bool SetDocumentationRaw(Documentation? value)
	{
		if (!ExchangeChildRaw(value, _documentation))
			return false;
		_documentation = value;
		return true;
	}

	/// <remarks>Optional Single Containment</remarks>
        public Geometry SetDocumentation(Documentation? value)
	{
		ContainmentSingleNotificationEmitter<Documentation> emitter = new(ShapesLanguage.Instance.Geometry_documentation, this, value, _documentation);
		emitter.CollectOldData();
		if (SetDocumentationRaw(value))
			emitter.Notify();
		return this;
	}

	private bool SetShapesRaw(List<IShape> nodes) => ExchangeChildrenRaw(nodes, _shapes);
	private bool AddShapesRaw(IShape? value) => AddChildRaw(value, _shapes);
	private bool InsertShapesRaw(int index, IShape? value) => InsertChildRaw(index, value, _shapes);
	private bool RemoveShapesRaw(IShape? value) => RemoveChildRaw(value, _shapes);
	private readonly List<IShape> _shapes = [];
	/// <remarks>Optional Multiple Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-shapes")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = true)]
	public IReadOnlyList<IShape> Shapes { get => _shapes.AsReadOnly(); init => AddShapes(value); }

	/// <remarks>Optional Multiple Containment</remarks>
        public bool TryGetShapes([NotNullWhenAttribute(true)] out IReadOnlyList<IShape> shapes)
	{
		shapes = _shapes.AsReadOnly();
		return shapes.Count != 0;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public Geometry AddShapes(IEnumerable<IShape> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.Geometry_shapes);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.Geometry_shapes);
		if (_shapes.SequenceEqual(safeNodes))
			return this;
		foreach (var safeNode in safeNodes)
		{
			ContainmentAddMultipleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.Geometry_shapes, this, safeNode, _shapes, null);
			emitter.CollectOldData();
			if (AddShapesRaw(safeNode))
				emitter.Notify();
		}

		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public Geometry InsertShapes(int index, IEnumerable<IShape> nodes)
	{
		AssureInRange(index, _shapes);
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.Geometry_shapes);
		AssureNoSelfMove(index, safeNodes, _shapes);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.Geometry_shapes);
		foreach (var safeNode in safeNodes)
		{
			ContainmentAddMultipleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.Geometry_shapes, this, safeNode, _shapes, index);
			emitter.CollectOldData();
			if (InsertShapesRaw(index++, safeNode))
				emitter.Notify();
		}

		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public Geometry RemoveShapes(IEnumerable<IShape> nodes)
	{
		RemoveSelfParent(nodes?.ToList(), _shapes, ShapesLanguage.Instance.Geometry_shapes, ContainmentRemover<IShape>(ShapesLanguage.Instance.Geometry_shapes));
		return this;
	}

	public Geometry(string id) : base(id)
	{
		_notificationProducer = new PartitionNotificationProducer(this);
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => ShapesLanguage.Instance.Geometry;
	private readonly IPartitionNotificationProducer? _notificationProducer;
	IPartitionNotificationProducer? IPartitionInstance.GetNotificationProducer() => _notificationProducer;
	/// <inheritdoc/>
        public INotificationSender? GetNotificationSender() => _notificationProducer;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Geometry_documentation.EqualsIdentity(feature))
		{
			result = Documentation;
			return true;
		}

		if (ShapesLanguage.Instance.Geometry_shapes.EqualsIdentity(feature))
		{
			result = Shapes;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetContainmentRaw(Containment feature, out IReadableNode? result)
	{
		if (base.TryGetContainmentRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Geometry_documentation.EqualsIdentity(feature))
		{
			result = _documentation;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetContainmentsRaw(Containment feature, out IReadOnlyList<IReadableNode> result)
	{
		if (base.TryGetContainmentsRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Geometry_shapes.EqualsIdentity(feature))
		{
			result = _shapes;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (ShapesLanguage.Instance.Geometry_documentation.EqualsIdentity(feature))
		{
			if (value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation)
			{
				SetDocumentation((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation?)value);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.Geometry_shapes.EqualsIdentity(feature))
		{
			var safeNodes = ShapesLanguage.Instance.Geometry_shapes.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value).ToList();
			ContainmentSetNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.Geometry_shapes, this, safeNodes, _shapes);
			emitter.CollectOldData();
			if (SetShapesRaw(safeNodes))
				emitter.Notify();
			return true;
		}

		return false;
	}

	protected internal override bool SetContainmentRaw(Containment feature, IWritableNode? value)
	{
		if (base.SetContainmentRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.Geometry_documentation.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation)
			return SetDocumentationRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetDocumentation(out _))
			result.Add(ShapesLanguage.Instance.Geometry_documentation);
		if (TryGetShapes(out _))
			result.Add(ShapesLanguage.Instance.Geometry_shapes);
		return result;
	}

	protected internal override bool AddContainmentsRaw(Containment feature, IWritableNode? value)
	{
		if (base.AddContainmentsRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.Geometry_shapes.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape)
			return AddShapesRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape?)value);
		return false;
	}

	protected internal override bool InsertContainmentsRaw(Containment feature, int index, IWritableNode? value)
	{
		if (base.InsertContainmentsRaw(feature, index, value))
			return true;
		if (ShapesLanguage.Instance.Geometry_shapes.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape)
			return InsertShapesRaw(index, (LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape?)value);
		return false;
	}

	protected internal override bool RemoveContainmentsRaw(Containment feature, IWritableNode? value)
	{
		if (base.RemoveContainmentsRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.Geometry_shapes.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape)
			return RemoveShapesRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape?)value);
		return false;
	}

	/// <inheritdoc/>
        protected override bool AddInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.AddInternal(link, value))
			return true;
		if (ShapesLanguage.Instance.Geometry_shapes.EqualsIdentity(link))
		{
			AddShapes(ShapesLanguage.Instance.Geometry_shapes.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool InsertInternal(Link? link, int index, IEnumerable<IReadableNode> value)
	{
		if (base.InsertInternal(link, index, value))
			return true;
		if (ShapesLanguage.Instance.Geometry_shapes.EqualsIdentity(link))
		{
			InsertShapes(index, ShapesLanguage.Instance.Geometry_shapes.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool RemoveInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.RemoveInternal(link, value))
			return true;
		if (ShapesLanguage.Instance.Geometry_shapes.EqualsIdentity(link))
		{
			RemoveShapes(ShapesLanguage.Instance.Geometry_shapes.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (ShapesLanguage.Instance.Geometry_documentation.EqualsIdentity(c))
		{
			_documentation = null;
			return true;
		}

		if (ShapesLanguage.Instance.Geometry_shapes.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _shapes, ShapesLanguage.Instance.Geometry_shapes);
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (ReferenceEquals(_documentation, child))
			return ShapesLanguage.Instance.Geometry_documentation;
		if (child is IShape child1 && _shapes.Contains(child1))
			return ShapesLanguage.Instance.Geometry_shapes;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-IShape")]
public partial interface IShape : INode
{
	/// <remarks>Optional Multiple Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-fixpoints")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = true)]
	public IReadOnlyList<Coord> Fixpoints { get; init; }

	/// <remarks>Optional Multiple Containment</remarks>
        public IShape AddFixpoints(IEnumerable<Coord> nodes);
	/// <remarks>Optional Multiple Containment</remarks>
        public IShape InsertFixpoints(int index, IEnumerable<Coord> nodes);
	/// <remarks>Optional Multiple Containment</remarks>
        public IShape RemoveFixpoints(IEnumerable<Coord> nodes);
	/// <remarks>Required Property</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-uuid")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string Uuid { get; set; }

	/// <remarks>Required Property</remarks>
        public IShape SetUuid(string value);
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-Line")]
public partial class Line : Shape, INamedWritable
{
	private Coord? _end = null;
	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If End has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-end")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = false)]
	public Coord End { get => _end ?? throw new UnsetFeatureException(ShapesLanguage.Instance.Line_end); set => SetEnd(value); }

	/// <remarks>Required Single Containment</remarks>
        public bool TryGetEnd([NotNullWhenAttribute(true)] out Coord? end)
	{
		end = _end;
		return end != null;
	}

	private bool SetEndRaw(Coord? value)
	{
		if (!ExchangeChildRaw(value, _end))
			return false;
		_end = value;
		return true;
	}

	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public Line SetEnd(Coord value)
	{
		AssureNotNull(value, ShapesLanguage.Instance.Line_end);
		ContainmentSingleNotificationEmitter<Coord> emitter = new(ShapesLanguage.Instance.Line_end, this, value, _end);
		emitter.CollectOldData();
		if (SetEndRaw(value))
			emitter.Notify();
		return this;
	}

	private Coord? _start = null;
	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If Start has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-start")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = false)]
	public Coord Start { get => _start ?? throw new UnsetFeatureException(ShapesLanguage.Instance.Line_start); set => SetStart(value); }

	/// <remarks>Required Single Containment</remarks>
        public bool TryGetStart([NotNullWhenAttribute(true)] out Coord? start)
	{
		start = _start;
		return start != null;
	}

	private bool SetStartRaw(Coord? value)
	{
		if (!ExchangeChildRaw(value, _start))
			return false;
		_start = value;
		return true;
	}

	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public Line SetStart(Coord value)
	{
		AssureNotNull(value, ShapesLanguage.Instance.Line_start);
		ContainmentSingleNotificationEmitter<Coord> emitter = new(ShapesLanguage.Instance.Line_start, this, value, _start);
		emitter.CollectOldData();
		if (SetStartRaw(value))
			emitter.Notify();
		return this;
	}

	public Line(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => ShapesLanguage.Instance.Line;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Line_end.EqualsIdentity(feature))
		{
			result = End;
			return true;
		}

		if (ShapesLanguage.Instance.Line_start.EqualsIdentity(feature))
		{
			result = Start;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetContainmentRaw(Containment feature, out IReadableNode? result)
	{
		if (base.TryGetContainmentRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Line_end.EqualsIdentity(feature))
		{
			result = _end;
			return true;
		}

		if (ShapesLanguage.Instance.Line_start.EqualsIdentity(feature))
		{
			result = _start;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (ShapesLanguage.Instance.Line_end.EqualsIdentity(feature))
		{
			if (value is LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord v)
			{
				SetEnd(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.Line_start.EqualsIdentity(feature))
		{
			if (value is LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord v)
			{
				SetStart(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected internal override bool SetContainmentRaw(Containment feature, IWritableNode? value)
	{
		if (base.SetContainmentRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.Line_end.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord)
			return SetEndRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord?)value);
		if (ShapesLanguage.Instance.Line_start.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord)
			return SetStartRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetEnd(out _))
			result.Add(ShapesLanguage.Instance.Line_end);
		if (TryGetStart(out _))
			result.Add(ShapesLanguage.Instance.Line_start);
		return result;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (ShapesLanguage.Instance.Line_end.EqualsIdentity(c))
		{
			_end = null;
			return true;
		}

		if (ShapesLanguage.Instance.Line_start.EqualsIdentity(c))
		{
			_start = null;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (ReferenceEquals(_end, child))
			return ShapesLanguage.Instance.Line_end;
		if (ReferenceEquals(_start, child))
			return ShapesLanguage.Instance.Line_start;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-MaterialGroup")]
public partial class MaterialGroup : ConceptInstanceBase
{
	private IShape? _defaultShape = null;
	/// <remarks>Optional Single Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-default-shape")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = false)]
	public IShape? DefaultShape { get => _defaultShape; set => SetDefaultShape(value); }

	/// <remarks>Optional Single Containment</remarks>
        public bool TryGetDefaultShape([NotNullWhenAttribute(true)] out IShape? defaultShape)
	{
		defaultShape = _defaultShape;
		return defaultShape != null;
	}

	private bool SetDefaultShapeRaw(IShape? value)
	{
		if (!ExchangeChildRaw(value, _defaultShape))
			return false;
		_defaultShape = value;
		return true;
	}

	/// <remarks>Optional Single Containment</remarks>
        public MaterialGroup SetDefaultShape(IShape? value)
	{
		ContainmentSingleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.MaterialGroup_defaultShape, this, value, _defaultShape);
		emitter.CollectOldData();
		if (SetDefaultShapeRaw(value))
			emitter.Notify();
		return this;
	}

	private readonly List<ReferenceTarget> _materials = [];
	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If Materials is empty</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-group-materials")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = true)]
	public IReadOnlyList<IShape> Materials { get => GetRequiredNonNullReferences<IShape>(_materials, ShapesLanguage.Instance.MaterialGroup_materials); init => AddMaterials(value); }

	/// <remarks>Required Multiple Reference</remarks>
        public bool TryGetMaterials([NotNullWhenAttribute(true)] out IReadOnlyList<IShape> materials) => TryGetReference<IShape>(_materials, out materials);
	private bool SetMaterialsRaw(List<ReferenceTarget> targets)
	{
		if (_materials.SequenceEqual(targets))
			return false;
		_materials.Clear();
		_materials.AddRange(targets);
		return true;
	}

	private bool AddMaterialsRaw(ReferenceTarget? target)
	{
		if (target is null)
			return false;
		_materials.Add(target);
		return true;
	}

	private bool InsertMaterialsRaw(int index, ReferenceTarget? target)
	{
		if (target is null || !IsInRange(index, _materials))
			return false;
		_materials.Insert(index, target);
		return true;
	}

	private bool RemoveMaterialsRaw(ReferenceTarget? target) => Remove(target, _materials);
	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If both Materials and nodes are empty</exception>
        public MaterialGroup AddMaterials(IEnumerable<IShape> nodes)
	{
		var safeNodes = nodes?.Select(ReferenceTarget.FromNode).ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.MaterialGroup_materials);
		AssureNonEmpty(safeNodes, _materials, ShapesLanguage.Instance.MaterialGroup_materials);
		ReferenceAddMultipleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.MaterialGroup_materials, this, safeNodes, _materials.Count);
		emitter.CollectOldData();
		_materials.AddRange(safeNodes);
		emitter.Notify();
		return this;
	}

	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If both Materials and nodes are empty</exception>
    	/// <exception cref = "ArgumentOutOfRangeException">If index negative or greater than Materials.Count</exception>
        public MaterialGroup InsertMaterials(int index, IEnumerable<IShape> nodes)
	{
		AssureInRange(index, _materials);
		var safeNodes = nodes?.Select(ReferenceTarget.FromNode).ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.MaterialGroup_materials);
		AssureNonEmpty(safeNodes, _materials, ShapesLanguage.Instance.MaterialGroup_materials);
		ReferenceAddMultipleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.MaterialGroup_materials, this, safeNodes, index);
		emitter.CollectOldData();
		_materials.InsertRange(index, safeNodes);
		emitter.Notify();
		return this;
	}

	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If Materials would be empty</exception>
        public MaterialGroup RemoveMaterials(IEnumerable<IShape> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.MaterialGroup_materials);
		AssureNonEmpty(safeNodes, _materials, ShapesLanguage.Instance.MaterialGroup_materials);
		AssureNotClearing(safeNodes, ReferenceTargetNullableTargets<IShape>(_materials, ShapesLanguage.Instance.MaterialGroup_materials), ShapesLanguage.Instance.MaterialGroup_materials);
		RemoveAll(safeNodes, _materials, ReferenceRemover<IShape>(ShapesLanguage.Instance.MaterialGroup_materials));
		return this;
	}

	private MatterState? _matterState = null;
	/// <remarks>Optional Property</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-matter-state")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = true, Multiple = false)]
	public MatterState? MatterState { get => _matterState; set => SetMatterState(value); }

	/// <remarks>Optional Property</remarks>
        public bool TryGetMatterState([NotNullWhenAttribute(true)] out MatterState? matterState)
	{
		matterState = _matterState;
		return matterState != null;
	}

	private bool SetMatterStateRaw(MatterState? value)
	{
		if (value == _matterState)
			return false;
		_matterState = value;
		return true;
	}

	/// <remarks>Optional Property</remarks>
        public MaterialGroup SetMatterState(MatterState? value)
	{
		PropertyNotificationEmitter emitter = new(ShapesLanguage.Instance.MaterialGroup_matterState, this, value, _matterState);
		emitter.CollectOldData();
		if (SetMatterStateRaw(value))
			emitter.Notify();
		return this;
	}

	public MaterialGroup(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => ShapesLanguage.Instance.MaterialGroup;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_defaultShape.EqualsIdentity(feature))
		{
			result = DefaultShape;
			return true;
		}

		if (ShapesLanguage.Instance.MaterialGroup_materials.EqualsIdentity(feature))
		{
			result = Materials;
			return true;
		}

		if (ShapesLanguage.Instance.MaterialGroup_matterState.EqualsIdentity(feature))
		{
			result = MatterState;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_matterState.EqualsIdentity(feature))
		{
			result = _matterState;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetContainmentRaw(Containment feature, out IReadableNode? result)
	{
		if (base.TryGetContainmentRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_defaultShape.EqualsIdentity(feature))
		{
			result = _defaultShape;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetReferencesRaw(Reference feature, out IReadOnlyList<IReferenceTarget> result)
	{
		if (base.TryGetReferencesRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_materials.EqualsIdentity(feature))
		{
			result = _materials;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_defaultShape.EqualsIdentity(feature))
		{
			if (value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape)
			{
				SetDefaultShape((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape?)value);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.MaterialGroup_materials.EqualsIdentity(feature))
		{
			var safeNodes = ShapesLanguage.Instance.MaterialGroup_materials.AsReferenceTargets<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value).ToList();
			AssureNonEmpty(safeNodes, ShapesLanguage.Instance.MaterialGroup_materials);
			ReferenceSetNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.MaterialGroup_materials, this, safeNodes, _materials);
			emitter.CollectOldData();
			if (SetMaterialsRaw(safeNodes))
				emitter.Notify();
			return true;
		}

		if (ShapesLanguage.Instance.MaterialGroup_matterState.EqualsIdentity(feature))
		{
			if (value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MatterState)
			{
				SetMatterState((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MatterState?)value);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected internal override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_matterState.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MatterState)
			return SetMatterStateRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.MatterState?)value);
		return false;
	}

	protected internal override bool SetContainmentRaw(Containment feature, IWritableNode? value)
	{
		if (base.SetContainmentRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_defaultShape.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape)
			return SetDefaultShapeRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetDefaultShape(out _))
			result.Add(ShapesLanguage.Instance.MaterialGroup_defaultShape);
		if (TryGetMaterials(out _))
			result.Add(ShapesLanguage.Instance.MaterialGroup_materials);
		if (TryGetMatterState(out _))
			result.Add(ShapesLanguage.Instance.MaterialGroup_matterState);
		return result;
	}

	protected internal override bool AddReferencesRaw(Reference feature, ReferenceTarget? value)
	{
		if (base.AddReferencesRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_materials.EqualsIdentity(feature))
			return AddMaterialsRaw(value);
		return false;
	}

	protected internal override bool InsertReferencesRaw(Reference feature, int index, ReferenceTarget? value)
	{
		if (base.InsertReferencesRaw(feature, index, value))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_materials.EqualsIdentity(feature))
			return InsertMaterialsRaw(index, value);
		return false;
	}

	protected internal override bool RemoveReferencesRaw(Reference feature, ReferenceTarget? value)
	{
		if (base.RemoveReferencesRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_materials.EqualsIdentity(feature))
			return RemoveMaterialsRaw(value);
		return false;
	}

	/// <inheritdoc/>
        protected override bool AddInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.AddInternal(link, value))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_materials.EqualsIdentity(link))
		{
			AddMaterials(ShapesLanguage.Instance.MaterialGroup_materials.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool InsertInternal(Link? link, int index, IEnumerable<IReadableNode> value)
	{
		if (base.InsertInternal(link, index, value))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_materials.EqualsIdentity(link))
		{
			InsertMaterials(index, ShapesLanguage.Instance.MaterialGroup_materials.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool RemoveInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.RemoveInternal(link, value))
			return true;
		if (ShapesLanguage.Instance.MaterialGroup_materials.EqualsIdentity(link))
		{
			RemoveMaterials(ShapesLanguage.Instance.MaterialGroup_materials.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (ShapesLanguage.Instance.MaterialGroup_defaultShape.EqualsIdentity(c))
		{
			_defaultShape = null;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (ReferenceEquals(_defaultShape, child))
			return ShapesLanguage.Instance.MaterialGroup_defaultShape;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-OffsetDuplicate")]
public partial class OffsetDuplicate : Shape
{
	private ReferenceTarget? _altSource = null;
	/// <remarks>Optional Single Reference</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-alt-source")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = true, Multiple = false)]
	public Shape? AltSource { get => ReferenceTargetNonNullTarget<Shape>(_altSource, ShapesLanguage.Instance.OffsetDuplicate_altSource); set => SetAltSource(value); }

	/// <remarks>Optional Single Reference</remarks>
        public bool TryGetAltSource([NotNullWhenAttribute(true)] out Shape? altSource)
	{
		altSource = ReferenceTargetNullableTarget<Shape>(_altSource, ShapesLanguage.Instance.OffsetDuplicate_altSource);
		return altSource != null;
	}

	private OffsetDuplicate SetAltSource(ReferenceTarget? value)
	{
		AssureNullableInstance<Shape>(value, ShapesLanguage.Instance.OffsetDuplicate_altSource);
		ReferenceSingleNotificationEmitter<Shape> emitter = new(ShapesLanguage.Instance.OffsetDuplicate_altSource, this, value, _altSource);
		emitter.CollectOldData();
		if (SetAltSourceRaw(value))
			emitter.Notify();
		return this;
	}

	private bool SetAltSourceRaw(ReferenceTarget? value)
	{
		if (value == _altSource)
			return false;
		_altSource = value;
		return true;
	}

	/// <remarks>Optional Single Reference</remarks>
        public OffsetDuplicate SetAltSource(Shape? value)
	{
		return SetAltSource(ReferenceTarget.FromNodeOptional(value));
	}

	private Documentation? _docs = null;
	/// <remarks>Optional Single Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-docs")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = false)]
	public Documentation? Docs { get => _docs; set => SetDocs(value); }

	/// <remarks>Optional Single Containment</remarks>
        public bool TryGetDocs([NotNullWhenAttribute(true)] out Documentation? docs)
	{
		docs = _docs;
		return docs != null;
	}

	private bool SetDocsRaw(Documentation? value)
	{
		if (!ExchangeChildRaw(value, _docs))
			return false;
		_docs = value;
		return true;
	}

	/// <remarks>Optional Single Containment</remarks>
        public OffsetDuplicate SetDocs(Documentation? value)
	{
		ContainmentSingleNotificationEmitter<Documentation> emitter = new(ShapesLanguage.Instance.OffsetDuplicate_docs, this, value, _docs);
		emitter.CollectOldData();
		if (SetDocsRaw(value))
			emitter.Notify();
		return this;
	}

	private Coord? _offset = null;
	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If Offset has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-offset")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = false)]
	public Coord Offset { get => _offset ?? throw new UnsetFeatureException(ShapesLanguage.Instance.OffsetDuplicate_offset); set => SetOffset(value); }

	/// <remarks>Required Single Containment</remarks>
        public bool TryGetOffset([NotNullWhenAttribute(true)] out Coord? offset)
	{
		offset = _offset;
		return offset != null;
	}

	private bool SetOffsetRaw(Coord? value)
	{
		if (!ExchangeChildRaw(value, _offset))
			return false;
		_offset = value;
		return true;
	}

	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public OffsetDuplicate SetOffset(Coord value)
	{
		AssureNotNull(value, ShapesLanguage.Instance.OffsetDuplicate_offset);
		ContainmentSingleNotificationEmitter<Coord> emitter = new(ShapesLanguage.Instance.OffsetDuplicate_offset, this, value, _offset);
		emitter.CollectOldData();
		if (SetOffsetRaw(value))
			emitter.Notify();
		return this;
	}

	private Documentation? _secretDocs = null;
	/// <remarks>Optional Single Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-secret-docs")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = false)]
	public Documentation? SecretDocs { get => _secretDocs; set => SetSecretDocs(value); }

	/// <remarks>Optional Single Containment</remarks>
        public bool TryGetSecretDocs([NotNullWhenAttribute(true)] out Documentation? secretDocs)
	{
		secretDocs = _secretDocs;
		return secretDocs != null;
	}

	private bool SetSecretDocsRaw(Documentation? value)
	{
		if (!ExchangeChildRaw(value, _secretDocs))
			return false;
		_secretDocs = value;
		return true;
	}

	/// <remarks>Optional Single Containment</remarks>
        public OffsetDuplicate SetSecretDocs(Documentation? value)
	{
		ContainmentSingleNotificationEmitter<Documentation> emitter = new(ShapesLanguage.Instance.OffsetDuplicate_secretDocs, this, value, _secretDocs);
		emitter.CollectOldData();
		if (SetSecretDocsRaw(value))
			emitter.Notify();
		return this;
	}

	private ReferenceTarget? _source = null;
	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If Source has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-source")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = false)]
	public Shape Source { get => ReferenceTargetNonNullTarget<Shape>(_source, ShapesLanguage.Instance.OffsetDuplicate_source) ?? throw new UnsetFeatureException(ShapesLanguage.Instance.OffsetDuplicate_source); set => SetSource(value); }

	/// <remarks>Required Single Reference</remarks>
        public bool TryGetSource([NotNullWhenAttribute(true)] out Shape? source)
	{
		source = ReferenceTargetNullableTarget<Shape>(_source, ShapesLanguage.Instance.OffsetDuplicate_source);
		return source != null;
	}

	private OffsetDuplicate SetSource(ReferenceTarget? value)
	{
		AssureNotNullInstance<Shape>(value, ShapesLanguage.Instance.OffsetDuplicate_source);
		ReferenceSingleNotificationEmitter<Shape> emitter = new(ShapesLanguage.Instance.OffsetDuplicate_source, this, value, _source);
		emitter.CollectOldData();
		if (SetSourceRaw(value))
			emitter.Notify();
		return this;
	}

	private bool SetSourceRaw(ReferenceTarget? value)
	{
		if (value == _source)
			return false;
		_source = value;
		return true;
	}

	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public OffsetDuplicate SetSource(Shape value)
	{
		return SetSource(ReferenceTarget.FromNodeOptional(value));
	}

	public OffsetDuplicate(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => ShapesLanguage.Instance.OffsetDuplicate;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (ShapesLanguage.Instance.OffsetDuplicate_altSource.EqualsIdentity(feature))
		{
			result = AltSource;
			return true;
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_docs.EqualsIdentity(feature))
		{
			result = Docs;
			return true;
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_offset.EqualsIdentity(feature))
		{
			result = Offset;
			return true;
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_secretDocs.EqualsIdentity(feature))
		{
			result = SecretDocs;
			return true;
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_source.EqualsIdentity(feature))
		{
			result = Source;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetContainmentRaw(Containment feature, out IReadableNode? result)
	{
		if (base.TryGetContainmentRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.OffsetDuplicate_docs.EqualsIdentity(feature))
		{
			result = _docs;
			return true;
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_offset.EqualsIdentity(feature))
		{
			result = _offset;
			return true;
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_secretDocs.EqualsIdentity(feature))
		{
			result = _secretDocs;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetReferenceRaw(Reference feature, out IReferenceTarget? result)
	{
		if (base.TryGetReferenceRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.OffsetDuplicate_altSource.EqualsIdentity(feature))
		{
			result = _altSource;
			return true;
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_source.EqualsIdentity(feature))
		{
			result = _source;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (ShapesLanguage.Instance.OffsetDuplicate_altSource.EqualsIdentity(feature))
		{
			if (value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Shape)
			{
				SetAltSource((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Shape?)value);
				return true;
			}

			if (value is ReferenceTarget target)
			{
				SetAltSource(target);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_docs.EqualsIdentity(feature))
		{
			if (value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation)
			{
				SetDocs((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation?)value);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_offset.EqualsIdentity(feature))
		{
			if (value is LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord v)
			{
				SetOffset(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_secretDocs.EqualsIdentity(feature))
		{
			if (value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation)
			{
				SetSecretDocs((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation?)value);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_source.EqualsIdentity(feature))
		{
			if (value is LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Shape v)
			{
				SetSource(v);
				return true;
			}

			if (value is ReferenceTarget target)
			{
				SetSource(target);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected internal override bool SetContainmentRaw(Containment feature, IWritableNode? value)
	{
		if (base.SetContainmentRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.OffsetDuplicate_docs.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation)
			return SetDocsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation?)value);
		if (ShapesLanguage.Instance.OffsetDuplicate_offset.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord)
			return SetOffsetRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord?)value);
		if (ShapesLanguage.Instance.OffsetDuplicate_secretDocs.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation)
			return SetSecretDocsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation?)value);
		return false;
	}

	protected internal override bool SetReferenceRaw(Reference feature, ReferenceTarget? value)
	{
		if (base.SetReferenceRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.OffsetDuplicate_altSource.EqualsIdentity(feature))
			return SetAltSourceRaw(value);
		if (ShapesLanguage.Instance.OffsetDuplicate_source.EqualsIdentity(feature))
			return SetSourceRaw(value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetAltSource(out _))
			result.Add(ShapesLanguage.Instance.OffsetDuplicate_altSource);
		if (TryGetDocs(out _))
			result.Add(ShapesLanguage.Instance.OffsetDuplicate_docs);
		if (TryGetOffset(out _))
			result.Add(ShapesLanguage.Instance.OffsetDuplicate_offset);
		if (TryGetSecretDocs(out _))
			result.Add(ShapesLanguage.Instance.OffsetDuplicate_secretDocs);
		if (TryGetSource(out _))
			result.Add(ShapesLanguage.Instance.OffsetDuplicate_source);
		return result;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (ShapesLanguage.Instance.OffsetDuplicate_docs.EqualsIdentity(c))
		{
			_docs = null;
			return true;
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_offset.EqualsIdentity(c))
		{
			_offset = null;
			return true;
		}

		if (ShapesLanguage.Instance.OffsetDuplicate_secretDocs.EqualsIdentity(c))
		{
			_secretDocs = null;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (ReferenceEquals(_docs, child))
			return ShapesLanguage.Instance.OffsetDuplicate_docs;
		if (ReferenceEquals(_offset, child))
			return ShapesLanguage.Instance.OffsetDuplicate_offset;
		if (ReferenceEquals(_secretDocs, child))
			return ShapesLanguage.Instance.OffsetDuplicate_secretDocs;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-ReferenceGeometry")]
public partial class ReferenceGeometry : ConceptInstanceBase, IPartitionInstance<INode>
{
	private readonly List<ReferenceTarget> _shapes = [];
	/// <remarks>Optional Multiple Reference</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-shapes-references")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = true, Multiple = true)]
	public IReadOnlyList<IShape> Shapes { get => ReferenceTargetNonNullTargets<IShape>(_shapes, ShapesLanguage.Instance.ReferenceGeometry_shapes); init => AddShapes(value); }

	/// <remarks>Optional Multiple Reference</remarks>
        public bool TryGetShapes([NotNullWhenAttribute(true)] out IReadOnlyList<IShape> shapes) => TryGetReference<IShape>(_shapes, out shapes);
	private bool SetShapesRaw(List<ReferenceTarget> targets)
	{
		if (_shapes.SequenceEqual(targets))
			return false;
		_shapes.Clear();
		_shapes.AddRange(targets);
		return true;
	}

	private bool AddShapesRaw(ReferenceTarget? target)
	{
		if (target is null)
			return false;
		_shapes.Add(target);
		return true;
	}

	private bool InsertShapesRaw(int index, ReferenceTarget? target)
	{
		if (target is null || !IsInRange(index, _shapes))
			return false;
		_shapes.Insert(index, target);
		return true;
	}

	private bool RemoveShapesRaw(ReferenceTarget? target) => Remove(target, _shapes);
	/// <remarks>Optional Multiple Reference</remarks>
        public ReferenceGeometry AddShapes(IEnumerable<IShape> nodes)
	{
		var safeNodes = nodes?.Select(ReferenceTarget.FromNode).ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.ReferenceGeometry_shapes);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.ReferenceGeometry_shapes);
		ReferenceAddMultipleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.ReferenceGeometry_shapes, this, safeNodes, _shapes.Count);
		emitter.CollectOldData();
		_shapes.AddRange(safeNodes);
		emitter.Notify();
		return this;
	}

	/// <remarks>Optional Multiple Reference</remarks>
        public ReferenceGeometry InsertShapes(int index, IEnumerable<IShape> nodes)
	{
		AssureInRange(index, _shapes);
		var safeNodes = nodes?.Select(ReferenceTarget.FromNode).ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.ReferenceGeometry_shapes);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.ReferenceGeometry_shapes);
		ReferenceAddMultipleNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.ReferenceGeometry_shapes, this, safeNodes, index);
		emitter.CollectOldData();
		_shapes.InsertRange(index, safeNodes);
		emitter.Notify();
		return this;
	}

	/// <remarks>Optional Multiple Reference</remarks>
        public ReferenceGeometry RemoveShapes(IEnumerable<IShape> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.ReferenceGeometry_shapes);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.ReferenceGeometry_shapes);
		RemoveAll(safeNodes, _shapes, ReferenceRemover<IShape>(ShapesLanguage.Instance.ReferenceGeometry_shapes));
		return this;
	}

	public ReferenceGeometry(string id) : base(id)
	{
		_notificationProducer = new PartitionNotificationProducer(this);
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => ShapesLanguage.Instance.ReferenceGeometry;
	private readonly IPartitionNotificationProducer? _notificationProducer;
	IPartitionNotificationProducer? IPartitionInstance.GetNotificationProducer() => _notificationProducer;
	/// <inheritdoc/>
        public INotificationSender? GetNotificationSender() => _notificationProducer;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (ShapesLanguage.Instance.ReferenceGeometry_shapes.EqualsIdentity(feature))
		{
			result = Shapes;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetReferencesRaw(Reference feature, out IReadOnlyList<IReferenceTarget> result)
	{
		if (base.TryGetReferencesRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.ReferenceGeometry_shapes.EqualsIdentity(feature))
		{
			result = _shapes;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (ShapesLanguage.Instance.ReferenceGeometry_shapes.EqualsIdentity(feature))
		{
			var safeNodes = ShapesLanguage.Instance.ReferenceGeometry_shapes.AsReferenceTargets<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value).ToList();
			AssureNotNull(safeNodes, ShapesLanguage.Instance.ReferenceGeometry_shapes);
			AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.ReferenceGeometry_shapes);
			ReferenceSetNotificationEmitter<IShape> emitter = new(ShapesLanguage.Instance.ReferenceGeometry_shapes, this, safeNodes, _shapes);
			emitter.CollectOldData();
			if (SetShapesRaw(safeNodes))
				emitter.Notify();
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetShapes(out _))
			result.Add(ShapesLanguage.Instance.ReferenceGeometry_shapes);
		return result;
	}

	protected internal override bool AddReferencesRaw(Reference feature, ReferenceTarget? value)
	{
		if (base.AddReferencesRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.ReferenceGeometry_shapes.EqualsIdentity(feature))
			return AddShapesRaw(value);
		return false;
	}

	protected internal override bool InsertReferencesRaw(Reference feature, int index, ReferenceTarget? value)
	{
		if (base.InsertReferencesRaw(feature, index, value))
			return true;
		if (ShapesLanguage.Instance.ReferenceGeometry_shapes.EqualsIdentity(feature))
			return InsertShapesRaw(index, value);
		return false;
	}

	protected internal override bool RemoveReferencesRaw(Reference feature, ReferenceTarget? value)
	{
		if (base.RemoveReferencesRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.ReferenceGeometry_shapes.EqualsIdentity(feature))
			return RemoveShapesRaw(value);
		return false;
	}

	/// <inheritdoc/>
        protected override bool AddInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.AddInternal(link, value))
			return true;
		if (ShapesLanguage.Instance.ReferenceGeometry_shapes.EqualsIdentity(link))
		{
			AddShapes(ShapesLanguage.Instance.ReferenceGeometry_shapes.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool InsertInternal(Link? link, int index, IEnumerable<IReadableNode> value)
	{
		if (base.InsertInternal(link, index, value))
			return true;
		if (ShapesLanguage.Instance.ReferenceGeometry_shapes.EqualsIdentity(link))
		{
			InsertShapes(index, ShapesLanguage.Instance.ReferenceGeometry_shapes.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool RemoveInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.RemoveInternal(link, value))
			return true;
		if (ShapesLanguage.Instance.ReferenceGeometry_shapes.EqualsIdentity(link))
		{
			RemoveShapes(ShapesLanguage.Instance.ReferenceGeometry_shapes.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.IShape>(value));
			return true;
		}

		return false;
	}
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-Shape")]
public abstract partial class Shape : ConceptInstanceBase, INamedWritable, IShape
{
	private string? _name = null;
	private bool SetNameRaw(string? value)
	{
		if (value == _name)
			return false;
		_name = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If Name has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(LionWeb.Core.VersionSpecific.V2025_1.BuiltInsLanguage_2025_1), Key = "LionCore-builtins-INamed-name")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string Name { get => _name ?? throw new UnsetFeatureException(_builtIns.INamed_name); set => SetName(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetName([NotNullWhenAttribute(true)] out string? name)
	{
		name = _name;
		return name != null;
	}
/// <remarks>Required Property</remarks>
/// <exception cref="InvalidValueException">If set to null</exception>
 INamedWritable INamedWritable.SetName(string value) => SetName(value);
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public Shape SetName(string value)
	{
		AssureNotNull(value, _builtIns.INamed_name);
		PropertyNotificationEmitter emitter = new(_builtIns.INamed_name, this, value, _name);
		emitter.CollectOldData();
		if (SetNameRaw(value))
			emitter.Notify();
		return this;
	}

	private bool SetFixpointsRaw(List<Coord> nodes) => ExchangeChildrenRaw(nodes, _fixpoints);
	private bool AddFixpointsRaw(Coord? value) => AddChildRaw(value, _fixpoints);
	private bool InsertFixpointsRaw(int index, Coord? value) => InsertChildRaw(index, value, _fixpoints);
	private bool RemoveFixpointsRaw(Coord? value) => RemoveChildRaw(value, _fixpoints);
	private readonly List<Coord> _fixpoints = [];
	/// <remarks>Optional Multiple Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-fixpoints")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = true)]
	public IReadOnlyList<Coord> Fixpoints { get => _fixpoints.AsReadOnly(); init => AddFixpoints(value); }

	/// <remarks>Optional Multiple Containment</remarks>
        public bool TryGetFixpoints([NotNullWhenAttribute(true)] out IReadOnlyList<Coord> fixpoints)
	{
		fixpoints = _fixpoints.AsReadOnly();
		return fixpoints.Count != 0;
	}
/// <remarks>Optional Multiple Containment</remarks>
 IShape IShape.AddFixpoints(IEnumerable<Coord> nodes) => AddFixpoints(nodes);
	/// <remarks>Optional Multiple Containment</remarks>
        public Shape AddFixpoints(IEnumerable<Coord> nodes)
	{
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.IShape_fixpoints);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.IShape_fixpoints);
		if (_fixpoints.SequenceEqual(safeNodes))
			return this;
		foreach (var safeNode in safeNodes)
		{
			ContainmentAddMultipleNotificationEmitter<Coord> emitter = new(ShapesLanguage.Instance.IShape_fixpoints, this, safeNode, _fixpoints, null);
			emitter.CollectOldData();
			if (AddFixpointsRaw(safeNode))
				emitter.Notify();
		}

		return this;
	}
/// <remarks>Optional Multiple Containment</remarks>
 IShape IShape.InsertFixpoints(int index, IEnumerable<Coord> nodes) => InsertFixpoints(index, nodes);
	/// <remarks>Optional Multiple Containment</remarks>
        public Shape InsertFixpoints(int index, IEnumerable<Coord> nodes)
	{
		AssureInRange(index, _fixpoints);
		var safeNodes = nodes?.ToList();
		AssureNotNull(safeNodes, ShapesLanguage.Instance.IShape_fixpoints);
		AssureNoSelfMove(index, safeNodes, _fixpoints);
		AssureNotNullMembers(safeNodes, ShapesLanguage.Instance.IShape_fixpoints);
		foreach (var safeNode in safeNodes)
		{
			ContainmentAddMultipleNotificationEmitter<Coord> emitter = new(ShapesLanguage.Instance.IShape_fixpoints, this, safeNode, _fixpoints, index);
			emitter.CollectOldData();
			if (InsertFixpointsRaw(index++, safeNode))
				emitter.Notify();
		}

		return this;
	}
/// <remarks>Optional Multiple Containment</remarks>
 IShape IShape.RemoveFixpoints(IEnumerable<Coord> nodes) => RemoveFixpoints(nodes);
	/// <remarks>Optional Multiple Containment</remarks>
        public Shape RemoveFixpoints(IEnumerable<Coord> nodes)
	{
		RemoveSelfParent(nodes?.ToList(), _fixpoints, ShapesLanguage.Instance.IShape_fixpoints, ContainmentRemover<Coord>(ShapesLanguage.Instance.IShape_fixpoints));
		return this;
	}

	private string? _uuid = null;
	private bool SetUuidRaw(string? value)
	{
		if (value == _uuid)
			return false;
		_uuid = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If Uuid has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-uuid")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string Uuid { get => _uuid ?? throw new UnsetFeatureException(ShapesLanguage.Instance.IShape_uuid); set => SetUuid(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetUuid([NotNullWhenAttribute(true)] out string? uuid)
	{
		uuid = _uuid;
		return uuid != null;
	}
/// <remarks>Required Property</remarks>
/// <exception cref="InvalidValueException">If set to null</exception>
 IShape IShape.SetUuid(string value) => SetUuid(value);
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public Shape SetUuid(string value)
	{
		AssureNotNull(value, ShapesLanguage.Instance.IShape_uuid);
		PropertyNotificationEmitter emitter = new(ShapesLanguage.Instance.IShape_uuid, this, value, _uuid);
		emitter.CollectOldData();
		if (SetUuidRaw(value))
			emitter.Notify();
		return this;
	}

	private Documentation? _shapeDocs = null;
	/// <remarks>Optional Single Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-shape-docs")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = false)]
	public Documentation? ShapeDocs { get => _shapeDocs; set => SetShapeDocs(value); }

	/// <remarks>Optional Single Containment</remarks>
        public bool TryGetShapeDocs([NotNullWhenAttribute(true)] out Documentation? shapeDocs)
	{
		shapeDocs = _shapeDocs;
		return shapeDocs != null;
	}

	private bool SetShapeDocsRaw(Documentation? value)
	{
		if (!ExchangeChildRaw(value, _shapeDocs))
			return false;
		_shapeDocs = value;
		return true;
	}

	/// <remarks>Optional Single Containment</remarks>
        public Shape SetShapeDocs(Documentation? value)
	{
		ContainmentSingleNotificationEmitter<Documentation> emitter = new(ShapesLanguage.Instance.Shape_shapeDocs, this, value, _shapeDocs);
		emitter.CollectOldData();
		if (SetShapeDocsRaw(value))
			emitter.Notify();
		return this;
	}

	public Shape(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => ShapesLanguage.Instance.Shape;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (_builtIns.INamed_name.EqualsIdentity(feature))
		{
			result = Name;
			return true;
		}

		if (ShapesLanguage.Instance.IShape_fixpoints.EqualsIdentity(feature))
		{
			result = Fixpoints;
			return true;
		}

		if (ShapesLanguage.Instance.IShape_uuid.EqualsIdentity(feature))
		{
			result = Uuid;
			return true;
		}

		if (ShapesLanguage.Instance.Shape_shapeDocs.EqualsIdentity(feature))
		{
			result = ShapeDocs;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (_builtIns.INamed_name.EqualsIdentity(feature))
		{
			result = _name;
			return true;
		}

		if (ShapesLanguage.Instance.IShape_uuid.EqualsIdentity(feature))
		{
			result = _uuid;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetContainmentRaw(Containment feature, out IReadableNode? result)
	{
		if (base.TryGetContainmentRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.Shape_shapeDocs.EqualsIdentity(feature))
		{
			result = _shapeDocs;
			return true;
		}

		return false;
	}

	protected internal override bool TryGetContainmentsRaw(Containment feature, out IReadOnlyList<IReadableNode> result)
	{
		if (base.TryGetContainmentsRaw(feature, out result))
			return true;
		if (ShapesLanguage.Instance.IShape_fixpoints.EqualsIdentity(feature))
		{
			result = _fixpoints;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (_builtIns.INamed_name.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				SetName(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.IShape_fixpoints.EqualsIdentity(feature))
		{
			var safeNodes = ShapesLanguage.Instance.IShape_fixpoints.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord>(value).ToList();
			ContainmentSetNotificationEmitter<Coord> emitter = new(ShapesLanguage.Instance.IShape_fixpoints, this, safeNodes, _fixpoints);
			emitter.CollectOldData();
			if (SetFixpointsRaw(safeNodes))
				emitter.Notify();
			return true;
		}

		if (ShapesLanguage.Instance.IShape_uuid.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				SetUuid(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (ShapesLanguage.Instance.Shape_shapeDocs.EqualsIdentity(feature))
		{
			if (value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation)
			{
				SetShapeDocs((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation?)value);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected internal override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (_builtIns.INamed_name.EqualsIdentity(feature) && value is null or string)
			return SetNameRaw((string?)value);
		if (ShapesLanguage.Instance.IShape_uuid.EqualsIdentity(feature) && value is null or string)
			return SetUuidRaw((string?)value);
		return false;
	}

	protected internal override bool SetContainmentRaw(Containment feature, IWritableNode? value)
	{
		if (base.SetContainmentRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.Shape_shapeDocs.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation)
			return SetShapeDocsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Documentation?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetName(out _))
			result.Add(_builtIns.INamed_name);
		if (TryGetFixpoints(out _))
			result.Add(ShapesLanguage.Instance.IShape_fixpoints);
		if (TryGetUuid(out _))
			result.Add(ShapesLanguage.Instance.IShape_uuid);
		if (TryGetShapeDocs(out _))
			result.Add(ShapesLanguage.Instance.Shape_shapeDocs);
		return result;
	}

	protected internal override bool AddContainmentsRaw(Containment feature, IWritableNode? value)
	{
		if (base.AddContainmentsRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.IShape_fixpoints.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord)
			return AddFixpointsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord?)value);
		return false;
	}

	protected internal override bool InsertContainmentsRaw(Containment feature, int index, IWritableNode? value)
	{
		if (base.InsertContainmentsRaw(feature, index, value))
			return true;
		if (ShapesLanguage.Instance.IShape_fixpoints.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord)
			return InsertFixpointsRaw(index, (LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord?)value);
		return false;
	}

	protected internal override bool RemoveContainmentsRaw(Containment feature, IWritableNode? value)
	{
		if (base.RemoveContainmentsRaw(feature, value))
			return true;
		if (ShapesLanguage.Instance.IShape_fixpoints.EqualsIdentity(feature) && value is null or LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord)
			return RemoveFixpointsRaw((LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord?)value);
		return false;
	}

	/// <inheritdoc/>
        protected override bool AddInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.AddInternal(link, value))
			return true;
		if (ShapesLanguage.Instance.IShape_fixpoints.EqualsIdentity(link))
		{
			AddFixpoints(ShapesLanguage.Instance.IShape_fixpoints.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool InsertInternal(Link? link, int index, IEnumerable<IReadableNode> value)
	{
		if (base.InsertInternal(link, index, value))
			return true;
		if (ShapesLanguage.Instance.IShape_fixpoints.EqualsIdentity(link))
		{
			InsertFixpoints(index, ShapesLanguage.Instance.IShape_fixpoints.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool RemoveInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.RemoveInternal(link, value))
			return true;
		if (ShapesLanguage.Instance.IShape_fixpoints.EqualsIdentity(link))
		{
			RemoveFixpoints(ShapesLanguage.Instance.IShape_fixpoints.AsNodes<LionWeb.Core.Test.Languages.Generated.V2025_1.Shapes.M2.Coord>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (ShapesLanguage.Instance.IShape_fixpoints.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _fixpoints, ShapesLanguage.Instance.IShape_fixpoints);
			return true;
		}

		if (ShapesLanguage.Instance.Shape_shapeDocs.EqualsIdentity(c))
		{
			_shapeDocs = null;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (child is Coord child0 && _fixpoints.Contains(child0))
			return ShapesLanguage.Instance.IShape_fixpoints;
		if (ReferenceEquals(_shapeDocs, child))
			return ShapesLanguage.Instance.Shape_shapeDocs;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-MatterState")]
public enum MatterState
{
	[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-gas")]
	gas,
	[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-liquid")]
	liquid,
	[LionCoreMetaPointer(Language = typeof(ShapesLanguage), Key = "key-solid")]
	solid
}