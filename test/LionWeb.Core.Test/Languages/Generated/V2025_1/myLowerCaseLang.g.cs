// Generated by the C# M2TypesGenerator: modify at your own risk!
// ReSharper disable InconsistentNaming
// ReSharper disable SuggestVarOrType_SimpleTypes
// ReSharper disable SuggestVarOrType_Elsewhere
#pragma warning disable 1591
#nullable enable
namespace LionWeb.Core.Test.Languages.Generated.V2025_1.myLowerCaseLang;
using LionWeb.Core;
using LionWeb.Core.M2;
using LionWeb.Core.M3;
using LionWeb.Core.Notification;
using LionWeb.Core.Notification.Partition.Emitter;
using LionWeb.Core.Utilities;
using LionWeb.Core.VersionSpecific.V2025_1;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

[LionCoreLanguage(Key = "key-LowerCaseLang", Version = "1")]
public partial class MyLowerCaseLangLanguage : LanguageBase<IMyLowerCaseLangFactory>
{
	public static readonly MyLowerCaseLangLanguage Instance = new Lazy<MyLowerCaseLangLanguage>(() => new("id-lowerCase-lang")).Value;
	public MyLowerCaseLangLanguage(string id) : base(id, LionWebVersions.v2025_1)
	{
		_myAnnotation = new(() => new AnnotationBase<MyLowerCaseLangLanguage>("id-annotation", this) { Key = "key-annotation", Name = "myAnnotation", AnnotatesLazy = new(() => _builtIns.Node) });
		_myConcept = new(() => new ConceptBase<MyLowerCaseLangLanguage>("id-concept", this) { Key = "key-concept", Name = "myConcept", Abstract = false, Partition = false, FeaturesLazy = new(() => [myConcept_myContainment, myConcept_myProperty, myConcept_myReference]) });
		_myConcept_myContainment = new(() => new ContainmentBase<MyLowerCaseLangLanguage>("id-containment", myConcept, this) { Key = "key-containment", Name = "myContainment", Optional = false, Multiple = false, Type = _builtIns.Node });
		_myConcept_myProperty = new(() => new PropertyBase<MyLowerCaseLangLanguage>("id-property", myConcept, this) { Key = "key-property", Name = "myProperty", Optional = false, Type = _builtIns.String });
		_myConcept_myReference = new(() => new ReferenceBase<MyLowerCaseLangLanguage>("id-reference", myConcept, this) { Key = "key-reference", Name = "myReference", Optional = false, Multiple = false, Type = _builtIns.Node });
		_myEnum = new(() => new EnumerationBase<MyLowerCaseLangLanguage>("id-enumeration", this) { Key = "key-enumeration", Name = "myEnum", LiteralsLazy = new(() => [myEnum_myLiteral]) });
		_myEnum_myLiteral = new(() => new EnumerationLiteralBase<MyLowerCaseLangLanguage>("id-literal", myEnum, this) { Key = "key-literal", Name = "myLiteral" });
		_mySdt = new(() => new StructuredDataTypeBase<MyLowerCaseLangLanguage>("id-sdt", this) { Key = "key-sdt", Name = "mySdt", FieldsLazy = new(() => [mySdt_myField]) });
		_mySdt_myField = new(() => new FieldBase<MyLowerCaseLangLanguage>("id-field", mySdt, this) { Key = "key-field", Name = "myField", Type = _builtIns.String });
		_factory = new MyLowerCaseLangFactory(this);
	}

	/// <inheritdoc/>
        public override IReadOnlyList<LanguageEntity> Entities => [myAnnotation, myConcept, myEnum, mySdt];
	/// <inheritdoc/>
        public override IReadOnlyList<Language> DependsOn => [];

	private const string _key = "key-LowerCaseLang";
	/// <inheritdoc/>
        public override string Key => _key;

	private const string _name = "myLowerCaseLang";
	/// <inheritdoc/>
        public override string Name => _name;

	private const string _version = "1";
	/// <inheritdoc/>
        public override string Version => _version;

	private readonly Lazy<Annotation> _myAnnotation;
	public Annotation myAnnotation => _myAnnotation.Value;

	private readonly Lazy<Concept> _myConcept;
	public Concept myConcept => _myConcept.Value;

	private readonly Lazy<Containment> _myConcept_myContainment;
	public Containment myConcept_myContainment => _myConcept_myContainment.Value;

	private readonly Lazy<Property> _myConcept_myProperty;
	public Property myConcept_myProperty => _myConcept_myProperty.Value;

	private readonly Lazy<Reference> _myConcept_myReference;
	public Reference myConcept_myReference => _myConcept_myReference.Value;

	private readonly Lazy<Enumeration> _myEnum;
	public Enumeration myEnum => _myEnum.Value;

	private readonly Lazy<EnumerationLiteral> _myEnum_myLiteral;
	public EnumerationLiteral myEnum_myLiteral => _myEnum_myLiteral.Value;

	private readonly Lazy<StructuredDataType> _mySdt;
	public StructuredDataType mySdt => _mySdt.Value;

	private readonly Lazy<Field> _mySdt_myField;
	public Field mySdt_myField => _mySdt_myField.Value;
}

public partial interface IMyLowerCaseLangFactory : INodeFactory
{
	public myAnnotation NewmyAnnotation(string id);
	public myAnnotation CreatemyAnnotation();
	public myConcept NewmyConcept(string id);
	public myConcept CreatemyConcept();
}

public class MyLowerCaseLangFactory : AbstractBaseNodeFactory, IMyLowerCaseLangFactory
{
	private readonly MyLowerCaseLangLanguage _language;
	public MyLowerCaseLangFactory(MyLowerCaseLangLanguage language) : base(language)
	{
		_language = language;
	}

	/// <inheritdoc/>
        public override INode CreateNode(string id, Classifier classifier)
	{
		if (_language.myAnnotation.EqualsIdentity(classifier))
			return NewmyAnnotation(id);
		if (_language.myConcept.EqualsIdentity(classifier))
			return NewmyConcept(id);
		throw new UnsupportedClassifierException(classifier);
	}

	/// <inheritdoc/>
        public override Enum GetEnumerationLiteral(EnumerationLiteral literal)
	{
		if (_language.myEnum.EqualsIdentity(literal.GetEnumeration()))
			return EnumValueFor<myEnum>(literal);
		throw new UnsupportedEnumerationLiteralException(literal);
	}

	/// <inheritdoc/>
        public override IStructuredDataTypeInstance CreateStructuredDataTypeInstance(StructuredDataType structuredDataType, IFieldValues fieldValues)
	{
		if (_language.mySdt.EqualsIdentity(structuredDataType))
			return new mySdt((string?)fieldValues.Get(_language.mySdt_myField));
		throw new UnsupportedStructuredDataTypeException(structuredDataType);
	}

	public virtual myAnnotation NewmyAnnotation(string id) => new(id);
	public virtual myAnnotation CreatemyAnnotation() => NewmyAnnotation(GetNewId());
	public virtual myConcept NewmyConcept(string id) => new(id);
	public virtual myConcept CreatemyConcept() => NewmyConcept(GetNewId());
}

/// <seealso cref = "MyLowerCaseLangLanguage"/>
/// <seealso cref = "myConcept"/>
/// <seealso cref = "myConcept.MyProperty"/>
/// <seealso cref = "myConcept.MyReference"/>
/// <seealso cref = "myConcept.MyContainment"/>
/// <seealso cref = "myEnum"/>
/// <seealso cref = "myEnum.myLiteral"/>
/// <seealso cref = "mySdt"/>
/// <seealso cref = "mySdt.MyField"/>
/// <seealso cref = "myAnnotation"/>
[LionCoreMetaPointer(Language = typeof(MyLowerCaseLangLanguage), Key = "key-annotation")]
public partial class myAnnotation : AnnotationInstanceBase
{
	public myAnnotation(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Annotation GetAnnotation() => MyLowerCaseLangLanguage.Instance.myAnnotation;
}

[LionCoreMetaPointer(Language = typeof(MyLowerCaseLangLanguage), Key = "key-concept")]
public partial class myConcept : ConceptInstanceBase
{
	private INode? _myContainment = null;
	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If MyContainment has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(MyLowerCaseLangLanguage), Key = "key-containment")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = false)]
	public INode MyContainment { get => _myContainment ?? throw new UnsetFeatureException(MyLowerCaseLangLanguage.Instance.myConcept_myContainment); set => SetMyContainment(value); }

	/// <remarks>Required Single Containment</remarks>
        public bool TryGetMyContainment([NotNullWhenAttribute(true)] out INode? myContainment)
	{
		myContainment = _myContainment;
		return myContainment != null;
	}

	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public myConcept SetMyContainment(INode value, INotificationId? notificationId = null)
	{
		AssureNotNull(value, MyLowerCaseLangLanguage.Instance.myConcept_myContainment);
		ContainmentSingleNotificationEmitter<INode> emitter = new(MyLowerCaseLangLanguage.Instance.myConcept_myContainment, this, value, _myContainment, notificationId);
		emitter.CollectOldData();
		SetParentNull(_myContainment);
		AttachChild(value);
		_myContainment = value;
		emitter.Notify();
		return this;
	}

	private string? _myProperty = null;
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If MyProperty has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(MyLowerCaseLangLanguage), Key = "key-property")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string MyProperty { get => _myProperty ?? throw new UnsetFeatureException(MyLowerCaseLangLanguage.Instance.myConcept_myProperty); set => SetMyProperty(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetMyProperty([NotNullWhenAttribute(true)] out string? myProperty)
	{
		myProperty = _myProperty;
		return myProperty != null;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public myConcept SetMyProperty(string value, INotificationId? notificationId = null)
	{
		AssureNotNull(value, MyLowerCaseLangLanguage.Instance.myConcept_myProperty);
		PropertyNotificationEmitter emitter = new(MyLowerCaseLangLanguage.Instance.myConcept_myProperty, this, value, _myProperty, notificationId);
		emitter.CollectOldData();
		_myProperty = value;
		emitter.Notify();
		return this;
	}

	private IReferenceDescriptor? _myReference = null;
	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If MyReference has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(MyLowerCaseLangLanguage), Key = "key-reference")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = false)]
	public IReadableNode MyReference { get => MyReferenceTarget() ?? throw new UnsetFeatureException(MyLowerCaseLangLanguage.Instance.myConcept_myReference); set => SetMyReference(value); }

	private IReadableNode? MyReferenceTarget() => ReferenceDescriptorNullableTarget<IReadableNode>(_myReference);
	/// <remarks>Required Single Reference</remarks>
        public bool TryGetMyReference([NotNullWhenAttribute(true)] out IReadableNode? myReference)
	{
		myReference = MyReferenceTarget();
		return myReference != null;
	}

	private myConcept SetMyReference(IReferenceDescriptor? value, INotificationId? notificationId = null)
	{
		AssureNotNull(value, MyLowerCaseLangLanguage.Instance.myConcept_myReference);
		ReferenceSingleNotificationEmitter<IReadableNode> emitter = new(MyLowerCaseLangLanguage.Instance.myConcept_myReference, this, value, _myReference, notificationId);
		emitter.CollectOldData();
		_myReference = value;
		emitter.Notify();
		return this;
	}

	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public myConcept SetMyReference(IReadableNode value, INotificationId? notificationId = null)
	{
		return SetMyReference(ReferenceDescriptorExtensions.FromNodeOptional(value), notificationId);
	}

	public myConcept(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => MyLowerCaseLangLanguage.Instance.myConcept;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (MyLowerCaseLangLanguage.Instance.myConcept_myContainment.EqualsIdentity(feature))
		{
			result = MyContainment;
			return true;
		}

		if (MyLowerCaseLangLanguage.Instance.myConcept_myProperty.EqualsIdentity(feature))
		{
			result = MyProperty;
			return true;
		}

		if (MyLowerCaseLangLanguage.Instance.myConcept_myReference.EqualsIdentity(feature))
		{
			result = MyReference;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (MyLowerCaseLangLanguage.Instance.myConcept_myContainment.EqualsIdentity(feature))
		{
			if (value is INode v)
			{
				SetMyContainment(v, notificationId);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (MyLowerCaseLangLanguage.Instance.myConcept_myProperty.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				SetMyProperty(v, notificationId);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (MyLowerCaseLangLanguage.Instance.myConcept_myReference.EqualsIdentity(feature))
		{
			if (value is IReadableNode v)
			{
				SetMyReference(v, notificationId);
				return true;
			}

			if (value is IReferenceDescriptor descriptor)
			{
				SetMyReference(descriptor, notificationId);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetMyContainment(out _))
			result.Add(MyLowerCaseLangLanguage.Instance.myConcept_myContainment);
		if (TryGetMyProperty(out _))
			result.Add(MyLowerCaseLangLanguage.Instance.myConcept_myProperty);
		if (TryGetMyReference(out _))
			result.Add(MyLowerCaseLangLanguage.Instance.myConcept_myReference);
		return result;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (MyLowerCaseLangLanguage.Instance.myConcept_myContainment.EqualsIdentity(c))
		{
			_myContainment = null;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (ReferenceEquals(_myContainment, child))
			return MyLowerCaseLangLanguage.Instance.myConcept_myContainment;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(MyLowerCaseLangLanguage), Key = "key-enumeration")]
public enum myEnum
{
	[LionCoreMetaPointer(Language = typeof(MyLowerCaseLangLanguage), Key = "key-literal")]
	myLiteral
}

[LionCoreMetaPointer(Language = typeof(MyLowerCaseLangLanguage), Key = "key-sdt")]
public readonly record struct mySdt : IStructuredDataTypeInstance
{
	private readonly string? _myField;
	[LionCoreMetaPointer(Language = typeof(MyLowerCaseLangLanguage), Key = "key-field")]
	public string MyField { get => _myField ?? throw new UnsetFieldException(MyLowerCaseLangLanguage.Instance.mySdt_myField); init => _myField = value; }

	public mySdt()
	{
		_myField = null;
	}

	internal mySdt(string? myField)
	{
		_myField = myField;
	}

	/// <inheritdoc/>
        public StructuredDataType GetStructuredDataType() => MyLowerCaseLangLanguage.Instance.mySdt;
	/// <inheritdoc/>
        public IEnumerable<Field> CollectAllSetFields()
	{
		List<Field> result = [];
		if (_myField != null)
			result.Add(MyLowerCaseLangLanguage.Instance.mySdt_myField);
		return result;
	}

	/// <inheritdoc/>
        public object? Get(Field field)
	{
		if (MyLowerCaseLangLanguage.Instance.mySdt_myField.EqualsIdentity(field))
			return MyField;
		throw new UnsetFieldException(field);
	}

	public override string ToString() => $"mySdt {{ MyField = {_myField} }}";
}