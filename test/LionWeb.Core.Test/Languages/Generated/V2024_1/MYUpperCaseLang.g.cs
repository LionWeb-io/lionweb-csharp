// Generated by the C# M2TypesGenerator: modify at your own risk!
// ReSharper disable InconsistentNaming
// ReSharper disable SuggestVarOrType_SimpleTypes
// ReSharper disable SuggestVarOrType_Elsewhere
#pragma warning disable 1591
#nullable enable
namespace LionWeb.Core.Test.Languages.Generated.V2024_1.MYUpperCaseLang;
using LionWeb.Core;
using LionWeb.Core.M2;
using LionWeb.Core.M3;
using LionWeb.Core.Notification;
using LionWeb.Core.Notification.Partition.Emitter;
using LionWeb.Core.Utilities;
using LionWeb.Core.VersionSpecific.V2024_1;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

[LionCoreLanguage(Key = "key-UpperCaseLang", Version = "1")]
public partial class MYUpperCaseLangLanguage : LanguageBase<IMYUpperCaseLangFactory>
{
	public static readonly MYUpperCaseLangLanguage Instance = new Lazy<MYUpperCaseLangLanguage>(() => new("id-UpperCase-lang")).Value;
	public MYUpperCaseLangLanguage(string id) : base(id, LionWebVersions.v2024_1)
	{
		_mYAnnotation = new(() => new AnnotationBase<MYUpperCaseLangLanguage>("id-annotation", this) { Key = "key-annotation", Name = "MYAnnotation", AnnotatesLazy = new(() => _builtIns.Node) });
		_mYConcept = new(() => new ConceptBase<MYUpperCaseLangLanguage>("id-concept", this) { Key = "key-concept", Name = "MYConcept", Abstract = false, Partition = false, FeaturesLazy = new(() => [MYConcept_MYContainment, MYConcept_MYProperty, MYConcept_MYReference]) });
		_mYConcept_MYContainment = new(() => new ContainmentBase<MYUpperCaseLangLanguage>("id-containment", MYConcept, this) { Key = "key-containment", Name = "MYContainment", Optional = false, Multiple = false, Type = _builtIns.Node });
		_mYConcept_MYProperty = new(() => new PropertyBase<MYUpperCaseLangLanguage>("id-property", MYConcept, this) { Key = "key-property", Name = "MYProperty", Optional = false, Type = _builtIns.String });
		_mYConcept_MYReference = new(() => new ReferenceBase<MYUpperCaseLangLanguage>("id-reference", MYConcept, this) { Key = "key-reference", Name = "MYReference", Optional = false, Multiple = false, Type = _builtIns.Node });
		_mYEnum = new(() => new EnumerationBase<MYUpperCaseLangLanguage>("id-enumeration", this) { Key = "key-enumeration", Name = "MYEnum", LiteralsLazy = new(() => [MYEnum_MYLiteral]) });
		_mYEnum_MYLiteral = new(() => new EnumerationLiteralBase<MYUpperCaseLangLanguage>("id-literal", MYEnum, this) { Key = "key-literal", Name = "MYLiteral" });
		_mYSdt = new(() => new StructuredDataTypeBase<MYUpperCaseLangLanguage>("id-sdt", this) { Key = "key-sdt", Name = "MYSdt", FieldsLazy = new(() => [MYSdt_MYField]) });
		_mYSdt_MYField = new(() => new FieldBase<MYUpperCaseLangLanguage>("id-field", MYSdt, this) { Key = "key-field", Name = "MYField", Type = _builtIns.String });
		_factory = new MYUpperCaseLangFactory(this);
	}

	/// <inheritdoc/>
        public override IReadOnlyList<LanguageEntity> Entities => [MYAnnotation, MYConcept, MYEnum, MYSdt];
	/// <inheritdoc/>
        public override IReadOnlyList<Language> DependsOn => [];

	private const string _key = "key-UpperCaseLang";
	/// <inheritdoc/>
        public override string Key => _key;

	private const string _name = "MYUpperCaseLang";
	/// <inheritdoc/>
        public override string Name => _name;

	private const string _version = "1";
	/// <inheritdoc/>
        public override string Version => _version;

	private readonly Lazy<Annotation> _mYAnnotation;
	public Annotation MYAnnotation => _mYAnnotation.Value;

	private readonly Lazy<Concept> _mYConcept;
	public Concept MYConcept => _mYConcept.Value;

	private readonly Lazy<Containment> _mYConcept_MYContainment;
	public Containment MYConcept_MYContainment => _mYConcept_MYContainment.Value;

	private readonly Lazy<Property> _mYConcept_MYProperty;
	public Property MYConcept_MYProperty => _mYConcept_MYProperty.Value;

	private readonly Lazy<Reference> _mYConcept_MYReference;
	public Reference MYConcept_MYReference => _mYConcept_MYReference.Value;

	private readonly Lazy<Enumeration> _mYEnum;
	public Enumeration MYEnum => _mYEnum.Value;

	private readonly Lazy<EnumerationLiteral> _mYEnum_MYLiteral;
	public EnumerationLiteral MYEnum_MYLiteral => _mYEnum_MYLiteral.Value;

	private readonly Lazy<StructuredDataType> _mYSdt;
	public StructuredDataType MYSdt => _mYSdt.Value;

	private readonly Lazy<Field> _mYSdt_MYField;
	public Field MYSdt_MYField => _mYSdt_MYField.Value;
}

public partial interface IMYUpperCaseLangFactory : INodeFactory
{
	public MYAnnotation NewMYAnnotation(string id);
	public MYAnnotation CreateMYAnnotation();
	public MYConcept NewMYConcept(string id);
	public MYConcept CreateMYConcept();
}

public class MYUpperCaseLangFactory : AbstractBaseNodeFactory, IMYUpperCaseLangFactory
{
	private readonly MYUpperCaseLangLanguage _language;
	public MYUpperCaseLangFactory(MYUpperCaseLangLanguage language) : base(language)
	{
		_language = language;
	}

	/// <inheritdoc/>
        public override INode CreateNode(string id, Classifier classifier)
	{
		if (_language.MYAnnotation.EqualsIdentity(classifier))
			return NewMYAnnotation(id);
		if (_language.MYConcept.EqualsIdentity(classifier))
			return NewMYConcept(id);
		throw new UnsupportedClassifierException(classifier);
	}

	/// <inheritdoc/>
        public override Enum GetEnumerationLiteral(EnumerationLiteral literal)
	{
		if (_language.MYEnum.EqualsIdentity(literal.GetEnumeration()))
			return EnumValueFor<MYEnum>(literal);
		throw new UnsupportedEnumerationLiteralException(literal);
	}

	/// <inheritdoc/>
        public override IStructuredDataTypeInstance CreateStructuredDataTypeInstance(StructuredDataType structuredDataType, IFieldValues fieldValues)
	{
		if (_language.MYSdt.EqualsIdentity(structuredDataType))
			return new MYSdt((string?)fieldValues.Get(_language.MYSdt_MYField));
		throw new UnsupportedStructuredDataTypeException(structuredDataType);
	}

	public virtual MYAnnotation NewMYAnnotation(string id) => new(id);
	public virtual MYAnnotation CreateMYAnnotation() => NewMYAnnotation(GetNewId());
	public virtual MYConcept NewMYConcept(string id) => new(id);
	public virtual MYConcept CreateMYConcept() => NewMYConcept(GetNewId());
}

/// <seealso cref = "MYUpperCaseLangLanguage"/>
/// <seealso cref = "MYConcept"/>
/// <seealso cref = "MYConcept.MYProperty"/>
/// <seealso cref = "MYConcept.MYReference"/>
/// <seealso cref = "MYConcept.MYContainment"/>
/// <seealso cref = "MYEnum"/>
/// <seealso cref = "MYEnum.MYLiteral"/>
/// <seealso cref = "MYSdt"/>
/// <seealso cref = "MYSdt.MYField"/>
/// <seealso cref = "MYAnnotation"/>
[LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-annotation")]
public partial class MYAnnotation : AnnotationInstanceBase
{
	public MYAnnotation(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Annotation GetAnnotation() => MYUpperCaseLangLanguage.Instance.MYAnnotation;
}

[LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-concept")]
public partial class MYConcept : ConceptInstanceBase
{
	private INode? _mYContainment = null;
	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If MYContainment has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-containment")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = false)]
	public INode MYContainment { get => _mYContainment ?? throw new UnsetFeatureException(MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment); set => SetMYContainment(value); }

	/// <remarks>Required Single Containment</remarks>
        public bool TryGetMYContainment([NotNullWhenAttribute(true)] out INode? mYContainment)
	{
		mYContainment = _mYContainment;
		return _mYContainment != null;
	}

	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public MYConcept SetMYContainment(INode value, INotificationId? notificationId = null)
	{
		AssureNotNull(value, MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment);
		ContainmentSingleNotificationEmitter<INode> emitter = new(MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment, this, value, _mYContainment, notificationId);
		emitter.CollectOldData();
		SetParentNull(_mYContainment);
		AttachChild(value);
		_mYContainment = value;
		emitter.Notify();
		return this;
	}

	private string? _mYProperty = null;
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If MYProperty has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-property")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string MYProperty { get => _mYProperty ?? throw new UnsetFeatureException(MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty); set => SetMYProperty(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetMYProperty([NotNullWhenAttribute(true)] out string? mYProperty)
	{
		mYProperty = _mYProperty;
		return _mYProperty != null;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public MYConcept SetMYProperty(string value, INotificationId? notificationId = null)
	{
		AssureNotNull(value, MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty);
		PropertyNotificationEmitter emitter = new(MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty, this, value, _mYProperty, notificationId);
		emitter.CollectOldData();
		_mYProperty = value;
		emitter.Notify();
		return this;
	}

	private IReadableNode? _mYReference = null;
	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If MYReference has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-reference")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = false)]
	public IReadableNode MYReference { get => _mYReference ?? throw new UnsetFeatureException(MYUpperCaseLangLanguage.Instance.MYConcept_MYReference); set => SetMYReference(value); }

	/// <remarks>Required Single Reference</remarks>
        public bool TryGetMYReference([NotNullWhenAttribute(true)] out IReadableNode? mYReference)
	{
		mYReference = _mYReference;
		return _mYReference != null;
	}

	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public MYConcept SetMYReference(IReadableNode value, INotificationId? notificationId = null)
	{
		AssureNotNull(value, MYUpperCaseLangLanguage.Instance.MYConcept_MYReference);
		ReferenceSingleNotificationEmitter emitter = new(MYUpperCaseLangLanguage.Instance.MYConcept_MYReference, this, value, _mYReference, notificationId);
		emitter.CollectOldData();
		_mYReference = value;
		emitter.Notify();
		return this;
	}

	public MYConcept(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => MYUpperCaseLangLanguage.Instance.MYConcept;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment.EqualsIdentity(feature))
		{
			result = MYContainment;
			return true;
		}

		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty.EqualsIdentity(feature))
		{
			result = MYProperty;
			return true;
		}

		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYReference.EqualsIdentity(feature))
		{
			result = MYReference;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment.EqualsIdentity(feature))
		{
			if (value is INode v)
			{
				SetMYContainment(v, notificationId);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				SetMYProperty(v, notificationId);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYReference.EqualsIdentity(feature))
		{
			if (value is IReadableNode v)
			{
				SetMYReference(v, notificationId);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetMYContainment(out _))
			result.Add(MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment);
		if (TryGetMYProperty(out _))
			result.Add(MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty);
		if (TryGetMYReference(out _))
			result.Add(MYUpperCaseLangLanguage.Instance.MYConcept_MYReference);
		return result;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment.EqualsIdentity(c))
		{
			_mYContainment = null;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (ReferenceEquals(_mYContainment, child))
			return MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-enumeration")]
public enum MYEnum
{
	[LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-literal")]
	MYLiteral
}

[LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-sdt")]
public readonly record struct MYSdt : IStructuredDataTypeInstance
{
	private readonly string? _mYField;
	[LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-field")]
	public string MYField { get => _mYField ?? throw new UnsetFieldException(MYUpperCaseLangLanguage.Instance.MYSdt_MYField); init => _mYField = value; }

	public MYSdt()
	{
		_mYField = null;
	}

	internal MYSdt(string? mYField)
	{
		_mYField = mYField;
	}

	/// <inheritdoc/>
        public StructuredDataType GetStructuredDataType() => MYUpperCaseLangLanguage.Instance.MYSdt;
	/// <inheritdoc/>
        public IEnumerable<Field> CollectAllSetFields()
	{
		List<Field> result = [];
		if (_mYField != null)
			result.Add(MYUpperCaseLangLanguage.Instance.MYSdt_MYField);
		return result;
	}

	/// <inheritdoc/>
        public object? Get(Field field)
	{
		if (MYUpperCaseLangLanguage.Instance.MYSdt_MYField.EqualsIdentity(field))
			return MYField;
		throw new UnsetFieldException(field);
	}

	public override string ToString() => $"MYSdt {{ MYField = {_mYField} }}";
}