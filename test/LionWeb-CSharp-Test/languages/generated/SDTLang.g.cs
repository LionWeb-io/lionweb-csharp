// Generated by the C# M2TypesGenerator: modify at your own risk!
// ReSharper disable InconsistentNaming
// ReSharper disable SuggestVarOrType_SimpleTypes
// ReSharper disable SuggestVarOrType_Elsewhere
#pragma warning disable 1591
#nullable enable
namespace Examples.SDTLang;
using LionWeb.Core;
using LionWeb.Core.M2;
using LionWeb.Core.M3;
using LionWeb.Core.Utilities;
using System;
using System.Collections.Generic;

[LionCoreLanguage(Key = "key-SDTLang", Version = "0")]
public class SDTLangLanguage : LanguageBase<ISDTLangFactory>
{
	public static readonly SDTLangLanguage Instance = new Lazy<SDTLangLanguage>(() => new("id-SDTLang")).Value;
	public SDTLangLanguage(string id) : base(id)
	{
		_sDTConcept = new(() => new ConceptBase<SDTLangLanguage>("id-SDTConcept", this) { Key = "key-SDTConcept", Name = "SDTConcept", Abstract = false, Partition = false, FeaturesLazy = new(() => [SDTConcept_amount, SDTConcept_decimal, SDTConcept_complex, SDTConcept_fqn]) });
		_sDTConcept_amount = new(() => new PropertyBase<SDTLangLanguage>("id-SDTamountField", SDTConcept, this) { Key = "key-SDTamountField", Name = "amount", Optional = false, Type = Amount });
		_sDTConcept_decimal = new(() => new PropertyBase<SDTLangLanguage>("id-SDTDecimalField", SDTConcept, this) { Key = "key-SDTDecimalField", Name = "decimal", Optional = false, Type = Decimal });
		_sDTConcept_complex = new(() => new PropertyBase<SDTLangLanguage>("id-SDTComplexField", SDTConcept, this) { Key = "key-SDTComplexField", Name = "complex", Optional = false, Type = ComplexNumber });
		_sDTConcept_fqn = new(() => new PropertyBase<SDTLangLanguage>("id-SDTFqnField", SDTConcept, this) { Key = "key-SDTFqnField", Name = "fqn", Optional = false, Type = FullyQualifiedName });
		_currency = new(() => new EnumerationBase<SDTLangLanguage>("id-SDTCurrency", this) { Key = "key-SDTCurrency", Name = "Currency", LiteralsLazy = new(() => [Currency_EUR, Currency_GBP]) });
		_currency_EUR = new(() => new EnumerationLiteralBase<SDTLangLanguage>("id-SDT-eur", Currency, this) { Key = "key-SDTEur", Name = "EUR" });
		_currency_GBP = new(() => new EnumerationLiteralBase<SDTLangLanguage>("id-SDT-gbp", Currency, this) { Key = "key-SDTGbp", Name = "GBP" });
		_amount = new(() => new StructuredDataTypeBase<SDTLangLanguage>("id-SDTAmount", this) { Key = "key-SDTAmount", Name = "Amount", FieldsLazy = new(() => [Amount_value, Amount_currency, Amount_digital]) });
		_amount_value = new(() => new FieldBase<SDTLangLanguage>("id-SDTValue", Amount, this) { Key = "key-SDTValue", Name = "value", Type = BuiltInsLanguage.Instance.Integer });
		_amount_currency = new(() => new FieldBase<SDTLangLanguage>("id-SDTCurrency", Amount, this) { Key = "key-SDTCurrency", Name = "currency", Type = Currency });
		_amount_digital = new(() => new FieldBase<SDTLangLanguage>("id-SDTDigital", Amount, this) { Key = "key-SDTDigital", Name = "digital", Type = BuiltInsLanguage.Instance.Boolean });
		_decimal = new(() => new StructuredDataTypeBase<SDTLangLanguage>("id-SDTDecimal", this) { Key = "key-SDTDecimal", Name = "Decimal", FieldsLazy = new(() => [Decimal_int, Decimal_frac]) });
		_decimal_int = new(() => new FieldBase<SDTLangLanguage>("id-SDTInt", Decimal, this) { Key = "key-SDTInt", Name = "int", Type = BuiltInsLanguage.Instance.Integer });
		_decimal_frac = new(() => new FieldBase<SDTLangLanguage>("id-SDTFrac", Decimal, this) { Key = "key-SDTFrac", Name = "frac", Type = BuiltInsLanguage.Instance.Integer });
		_complexNumber = new(() => new StructuredDataTypeBase<SDTLangLanguage>("id-SDTComplexNumber", this) { Key = "key-SDTComplexNumber", Name = "ComplexNumber", FieldsLazy = new(() => [ComplexNumber_real, ComplexNumber_imaginary]) });
		_complexNumber_real = new(() => new FieldBase<SDTLangLanguage>("id-SDTReal", ComplexNumber, this) { Key = "key-SDTReal", Name = "real", Type = Decimal });
		_complexNumber_imaginary = new(() => new FieldBase<SDTLangLanguage>("id-SDTImaginary", ComplexNumber, this) { Key = "key-SDTImaginary", Name = "imaginary", Type = Decimal });
		_fullyQualifiedName = new(() => new StructuredDataTypeBase<SDTLangLanguage>("id-SDTFullyQualifiedName", this) { Key = "key-SDTFullyQualifiedName", Name = "FullyQualifiedName", FieldsLazy = new(() => [FullyQualifiedName_name, FullyQualifiedName_nested]) });
		_fullyQualifiedName_name = new(() => new FieldBase<SDTLangLanguage>("id-SDT-FQN-name", FullyQualifiedName, this) { Key = "key-SDTFqnName", Name = "name", Type = BuiltInsLanguage.Instance.String });
		_fullyQualifiedName_nested = new(() => new FieldBase<SDTLangLanguage>("id-SDT-FQN-nested", FullyQualifiedName, this) { Key = "key-SDTFqnNested", Name = "nested", Type = FullyQualifiedName });
	}

	/// <inheritdoc/>
        public override IReadOnlyList<LanguageEntity> Entities => [SDTConcept, Currency, Amount, Decimal, ComplexNumber, FullyQualifiedName];
	/// <inheritdoc/>
        public override IReadOnlyList<Language> DependsOn => [];

	/// <inheritdoc/>
        public override ISDTLangFactory GetFactory() => new SDTLangFactory(this);
	private const string _key = "key-SDTLang";
	/// <inheritdoc/>
        public override string Key => _key;

	private const string _name = "SDTLang";
	/// <inheritdoc/>
        public override string Name => _name;

	private const string _version = "0";
	/// <inheritdoc/>
        public override string Version => _version;

	private readonly Lazy<Concept> _sDTConcept;
	public Concept SDTConcept => _sDTConcept.Value;

	private readonly Lazy<Property> _sDTConcept_amount;
	public Property SDTConcept_amount => _sDTConcept_amount.Value;

	private readonly Lazy<Property> _sDTConcept_decimal;
	public Property SDTConcept_decimal => _sDTConcept_decimal.Value;

	private readonly Lazy<Property> _sDTConcept_complex;
	public Property SDTConcept_complex => _sDTConcept_complex.Value;

	private readonly Lazy<Property> _sDTConcept_fqn;
	public Property SDTConcept_fqn => _sDTConcept_fqn.Value;

	private readonly Lazy<Enumeration> _currency;
	public Enumeration Currency => _currency.Value;

	private readonly Lazy<EnumerationLiteral> _currency_EUR;
	public EnumerationLiteral Currency_EUR => _currency_EUR.Value;

	private readonly Lazy<EnumerationLiteral> _currency_GBP;
	public EnumerationLiteral Currency_GBP => _currency_GBP.Value;

	private readonly Lazy<StructuredDataType> _amount;
	public StructuredDataType Amount => _amount.Value;

	private readonly Lazy<Field> _amount_value;
	public Field Amount_value => _amount_value.Value;

	private readonly Lazy<Field> _amount_currency;
	public Field Amount_currency => _amount_currency.Value;

	private readonly Lazy<Field> _amount_digital;
	public Field Amount_digital => _amount_digital.Value;

	private readonly Lazy<StructuredDataType> _decimal;
	public StructuredDataType Decimal => _decimal.Value;

	private readonly Lazy<Field> _decimal_int;
	public Field Decimal_int => _decimal_int.Value;

	private readonly Lazy<Field> _decimal_frac;
	public Field Decimal_frac => _decimal_frac.Value;

	private readonly Lazy<StructuredDataType> _complexNumber;
	public StructuredDataType ComplexNumber => _complexNumber.Value;

	private readonly Lazy<Field> _complexNumber_real;
	public Field ComplexNumber_real => _complexNumber_real.Value;

	private readonly Lazy<Field> _complexNumber_imaginary;
	public Field ComplexNumber_imaginary => _complexNumber_imaginary.Value;

	private readonly Lazy<StructuredDataType> _fullyQualifiedName;
	public StructuredDataType FullyQualifiedName => _fullyQualifiedName.Value;

	private readonly Lazy<Field> _fullyQualifiedName_name;
	public Field FullyQualifiedName_name => _fullyQualifiedName_name.Value;

	private readonly Lazy<Field> _fullyQualifiedName_nested;
	public Field FullyQualifiedName_nested => _fullyQualifiedName_nested.Value;
}

public interface ISDTLangFactory : INodeFactory
{
	public SDTConcept NewSDTConcept(string id);
	public SDTConcept CreateSDTConcept();
}

public class SDTLangFactory : AbstractBaseNodeFactory, ISDTLangFactory
{
	private readonly SDTLangLanguage _language;
	public SDTLangFactory(SDTLangLanguage language) : base(language)
	{
		_language = language;
	}

	/// <inheritdoc/>
        public override INode CreateNode(string id, Classifier classifier)
	{
		if (_language.SDTConcept.EqualsIdentity(classifier))
			return NewSDTConcept(id);
		throw new UnsupportedClassifierException(classifier);
	}

	/// <inheritdoc/>
        public override Enum GetEnumerationLiteral(EnumerationLiteral literal)
	{
		if (_language.Currency.EqualsIdentity(literal.GetEnumeration()))
			return EnumValueFor<Currency>(literal);
		throw new UnsupportedEnumerationLiteralException(literal);
	}

	public virtual SDTConcept NewSDTConcept(string id) => new(id);
	public virtual SDTConcept CreateSDTConcept() => NewSDTConcept(GetNewId());
}

[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTConcept")]
public partial class SDTConcept : NodeBase
{
	private Amount? _amount = null;
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If Amount has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTamountField")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public Amount Amount { get => _amount ?? throw new UnsetFeatureException(SDTLangLanguage.Instance.SDTConcept_amount); set => SetAmount(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public SDTConcept SetAmount(Amount value)
	{
		AssureNotNull(value, SDTLangLanguage.Instance.SDTConcept_amount);
		_amount = value;
		return this;
	}

	private Decimal? _decimal = null;
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If Decimal has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTDecimalField")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public Decimal Decimal { get => _decimal ?? throw new UnsetFeatureException(SDTLangLanguage.Instance.SDTConcept_decimal); set => SetDecimal(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public SDTConcept SetDecimal(Decimal value)
	{
		AssureNotNull(value, SDTLangLanguage.Instance.SDTConcept_decimal);
		_decimal = value;
		return this;
	}

	private ComplexNumber? _complex = null;
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If Complex has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTComplexField")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public ComplexNumber Complex { get => _complex ?? throw new UnsetFeatureException(SDTLangLanguage.Instance.SDTConcept_complex); set => SetComplex(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public SDTConcept SetComplex(ComplexNumber value)
	{
		AssureNotNull(value, SDTLangLanguage.Instance.SDTConcept_complex);
		_complex = value;
		return this;
	}

	private FullyQualifiedName? _fqn = null;
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If Fqn has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTFqnField")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public FullyQualifiedName Fqn { get => _fqn ?? throw new UnsetFeatureException(SDTLangLanguage.Instance.SDTConcept_fqn); set => SetFqn(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public SDTConcept SetFqn(FullyQualifiedName value)
	{
		AssureNotNull(value, SDTLangLanguage.Instance.SDTConcept_fqn);
		_fqn = value;
		return this;
	}

	public SDTConcept(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Classifier GetClassifier() => SDTLangLanguage.Instance.SDTConcept;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out Object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (SDTLangLanguage.Instance.SDTConcept_amount.EqualsIdentity(feature))
		{
			result = Amount;
			return true;
		}

		if (SDTLangLanguage.Instance.SDTConcept_decimal.EqualsIdentity(feature))
		{
			result = Decimal;
			return true;
		}

		if (SDTLangLanguage.Instance.SDTConcept_complex.EqualsIdentity(feature))
		{
			result = Complex;
			return true;
		}

		if (SDTLangLanguage.Instance.SDTConcept_fqn.EqualsIdentity(feature))
		{
			result = Fqn;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, Object? value)
	{
		if (base.SetInternal(feature, value))
			return true;
		if (SDTLangLanguage.Instance.SDTConcept_amount.EqualsIdentity(feature))
		{
			if (value is Examples.SDTLang.Amount v)
			{
				Amount = v;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (SDTLangLanguage.Instance.SDTConcept_decimal.EqualsIdentity(feature))
		{
			if (value is Examples.SDTLang.Decimal v)
			{
				Decimal = v;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (SDTLangLanguage.Instance.SDTConcept_complex.EqualsIdentity(feature))
		{
			if (value is Examples.SDTLang.ComplexNumber v)
			{
				Complex = v;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (SDTLangLanguage.Instance.SDTConcept_fqn.EqualsIdentity(feature))
		{
			if (value is Examples.SDTLang.FullyQualifiedName v)
			{
				Fqn = v;
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		var result = base.CollectAllSetFeatures().ToList();
		if (_amount != default)
			result.Add(SDTLangLanguage.Instance.SDTConcept_amount);
		if (_decimal != default)
			result.Add(SDTLangLanguage.Instance.SDTConcept_decimal);
		if (_complex != default)
			result.Add(SDTLangLanguage.Instance.SDTConcept_complex);
		if (_fqn != default)
			result.Add(SDTLangLanguage.Instance.SDTConcept_fqn);
		return result;
	}
}

[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTCurrency")]
public enum Currency
{
	[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTEur")]
	@EUR,
	[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTGbp")]
	@GBP
}

[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTAmount")]
public readonly record struct Amount
{
	private readonly int? _value;
	[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTValue")]
	public int Value { get => _value ?? throw new UnsetFieldException(SDTLangLanguage.Instance.Amount_value); init => _value = value; }

	private readonly Currency? _currency;
	[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTCurrency")]
	public Currency Currency { get => _currency ?? throw new UnsetFieldException(SDTLangLanguage.Instance.Amount_currency); init => _currency = value; }

	private readonly bool? _digital;
	[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTDigital")]
	public bool Digital { get => _digital ?? throw new UnsetFieldException(SDTLangLanguage.Instance.Amount_digital); init => _digital = value; }
}

[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTDecimal")]
public readonly record struct Decimal
{
	private readonly int? _int;
	[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTInt")]
	public int Int { get => _int ?? throw new UnsetFieldException(SDTLangLanguage.Instance.Decimal_int); init => _int = value; }

	private readonly int? _frac;
	[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTFrac")]
	public int Frac { get => _frac ?? throw new UnsetFieldException(SDTLangLanguage.Instance.Decimal_frac); init => _frac = value; }
}

[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTComplexNumber")]
public readonly record struct ComplexNumber
{
	private readonly Decimal? _real;
	[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTReal")]
	public Decimal Real { get => _real ?? throw new UnsetFieldException(SDTLangLanguage.Instance.ComplexNumber_real); init => _real = value; }

	private readonly Decimal? _imaginary;
	[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTImaginary")]
	public Decimal Imaginary { get => _imaginary ?? throw new UnsetFieldException(SDTLangLanguage.Instance.ComplexNumber_imaginary); init => _imaginary = value; }
}

[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTFullyQualifiedName")]
public readonly record struct FullyQualifiedName
{
	private readonly string? _name;
	[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTFqnName")]
	public string Name { get => _name ?? throw new UnsetFieldException(SDTLangLanguage.Instance.FullyQualifiedName_name); init => _name = value; }

	private readonly Lazy<FullyQualifiedName?>? _nested;
	[LionCoreMetaPointer(Language = typeof(SDTLangLanguage), Key = "key-SDTFqnNested")]
	public FullyQualifiedName? Nested { get => _nested?.Value; init => _nested = new(value); }
}