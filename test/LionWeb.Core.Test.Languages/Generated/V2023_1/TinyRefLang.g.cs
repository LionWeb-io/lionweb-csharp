// Generated by the C# M2TypesGenerator: modify at your own risk!
// ReSharper disable InconsistentNaming
// ReSharper disable SuggestVarOrType_SimpleTypes
// ReSharper disable SuggestVarOrType_Elsewhere
#pragma warning disable 1591
#nullable enable
namespace LionWeb.Core.Test.Languages.Generated.V2023_1.TinyRefLang;
using LionWeb.Core;
using LionWeb.Core.M2;
using LionWeb.Core.M3;
using LionWeb.Core.Notification;
using LionWeb.Core.Utilities;
using LionWeb.Core.VersionSpecific.V2023_1;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

[LionCoreLanguage(Key = "key-tinyRefLang", Version = "0")]
public partial class TinyRefLangLanguage : LanguageBase<ITinyRefLangFactory>
{
	public static readonly TinyRefLangLanguage Instance = new Lazy<TinyRefLangLanguage>(() => new("id-TinyRefLang")).Value;
	public TinyRefLangLanguage(string id) : base(id, LionWebVersions.v2023_1)
	{
		_myConcept = new(() => new ConceptBase<TinyRefLangLanguage>("id-Concept", this) { Key = "key-MyConcept", Name = "MyConcept", Abstract = false, Partition = false, ImplementsLazy = new(() => [_builtIns.INamed]), FeaturesLazy = new(() => [MyConcept_multivaluedRef, MyConcept_singularRef]) });
		_myConcept_multivaluedRef = new(() => new ReferenceBase<TinyRefLangLanguage>("id-Concept-multivaluedRef", MyConcept, this) { Key = "key-MyConcept-multivaluedRef", Name = "multivaluedRef", Optional = false, Multiple = true, Type = _builtIns.INamed });
		_myConcept_singularRef = new(() => new ReferenceBase<TinyRefLangLanguage>("id-MyConcept-singularRef", MyConcept, this) { Key = "key-MyConcept-singularRef", Name = "singularRef", Optional = false, Multiple = false, Type = _builtIns.INamed });
		_factory = new TinyRefLangFactory(this);
	}

	/// <inheritdoc/>
        public override IReadOnlyList<LanguageEntity> Entities => [MyConcept];
	/// <inheritdoc/>
        public override IReadOnlyList<Language> DependsOn => [];

	private const string _key = "key-tinyRefLang";
	/// <inheritdoc/>
        public override string Key => _key;

	private const string _name = "TinyRefLang";
	/// <inheritdoc/>
        public override string Name => _name;

	private const string _version = "0";
	/// <inheritdoc/>
        public override string Version => _version;

	private readonly Lazy<Concept> _myConcept;
	public Concept MyConcept => _myConcept.Value;

	private readonly Lazy<Reference> _myConcept_multivaluedRef;
	public Reference MyConcept_multivaluedRef => _myConcept_multivaluedRef.Value;

	private readonly Lazy<Reference> _myConcept_singularRef;
	public Reference MyConcept_singularRef => _myConcept_singularRef.Value;
}

public partial interface ITinyRefLangFactory : INodeFactory
{
	public MyConcept NewMyConcept(string id);
	public MyConcept CreateMyConcept();
}

public class TinyRefLangFactory : AbstractBaseNodeFactory, ITinyRefLangFactory
{
	private readonly TinyRefLangLanguage _language;
	public TinyRefLangFactory(TinyRefLangLanguage language) : base(language)
	{
		_language = language;
	}

	/// <inheritdoc/>
        public override INode CreateNode(string id, Classifier classifier)
	{
		if (_language.MyConcept.EqualsIdentity(classifier))
			return NewMyConcept(id);
		throw new UnsupportedClassifierException(classifier);
	}

	/// <inheritdoc/>
        public override Enum GetEnumerationLiteral(EnumerationLiteral literal)
	{
		throw new UnsupportedEnumerationLiteralException(literal);
	}

	/// <inheritdoc/>
        public override IStructuredDataTypeInstance CreateStructuredDataTypeInstance(StructuredDataType structuredDataType, IFieldValues fieldValues)
	{
		throw new UnsupportedStructuredDataTypeException(structuredDataType);
	}

	public virtual MyConcept NewMyConcept(string id) => new(id);
	public virtual MyConcept CreateMyConcept() => NewMyConcept(GetNewId());
}

[LionCoreMetaPointer(Language = typeof(TinyRefLangLanguage), Key = "key-MyConcept")]
public partial class MyConcept : ConceptInstanceBase, INamedWritable
{
	private string? _name = null;
	private bool SetNameRaw(string? value)
	{
		if (value == _name)
			return false;
		_name = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If Name has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(LionWeb.Core.VersionSpecific.V2023_1.BuiltInsLanguage_2023_1), Key = "LionCore-builtins-INamed-name")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string Name { get => _name ?? throw new UnsetFeatureException(_builtIns.INamed_name); set => SetName(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetName([NotNullWhenAttribute(true)] out string? name)
	{
		name = _name;
		return name != null;
	}
/// <remarks>Required Property</remarks>
/// <exception cref="InvalidValueException">If set to null</exception>
 INamedWritable INamedWritable.SetName(string value) => SetName(value);
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public MyConcept SetName(string value)
	{
		SetRequiredReferenceTypeProperty<string>(value, _builtIns.INamed_name, _name, SetNameRaw);
		return this;
	}

	private readonly List<ReferenceTarget> _multivaluedRef = [];
	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If MultivaluedRef is empty</exception>
        [LionCoreMetaPointer(Language = typeof(TinyRefLangLanguage), Key = "key-MyConcept-multivaluedRef")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = true)]
	public IReadOnlyList<INamed> MultivaluedRef { get => GetRequiredNonNullReferences<INamed>(_multivaluedRef, TinyRefLangLanguage.Instance.MyConcept_multivaluedRef); init => AddMultivaluedRef(value); }

	/// <remarks>Required Multiple Reference</remarks>
        public bool TryGetMultivaluedRef([NotNullWhenAttribute(true)] out IReadOnlyList<INamed> multivaluedRef) => TryGetReference<INamed>(_multivaluedRef, out multivaluedRef);
	private bool SetMultivaluedRefRaw(List<ReferenceTarget> targets) => SetReferencesRaw(targets, _multivaluedRef);
	private bool AddMultivaluedRefRaw(ReferenceTarget target) => AddReferencesRaw(target, _multivaluedRef);
	private bool InsertMultivaluedRefRaw(int index, ReferenceTarget target) => InsertReferencesRaw(index, target, _multivaluedRef);
	private bool RemoveMultivaluedRefRaw(ReferenceTarget target) => RemoveReferencesRaw(target, _multivaluedRef);
	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If both MultivaluedRef and nodes are empty</exception>
        public MyConcept AddMultivaluedRef(IEnumerable<INamed> nodes)
	{
		AddRequiredMultipleReference<INamed>(nodes, TinyRefLangLanguage.Instance.MyConcept_multivaluedRef, _multivaluedRef, AddMultivaluedRefRaw);
		return this;
	}

	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If both MultivaluedRef and nodes are empty</exception>
    	/// <exception cref = "ArgumentOutOfRangeException">If index negative or greater than MultivaluedRef.Count</exception>
        public MyConcept InsertMultivaluedRef(int index, IEnumerable<INamed> nodes)
	{
		InsertRequiredMultipleReference<INamed>(index, nodes, TinyRefLangLanguage.Instance.MyConcept_multivaluedRef, _multivaluedRef, InsertMultivaluedRefRaw);
		return this;
	}

	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If MultivaluedRef would be empty</exception>
        public MyConcept RemoveMultivaluedRef(IEnumerable<INamed> nodes)
	{
		RemoveRequiredMultipleReference<INamed>(nodes, TinyRefLangLanguage.Instance.MyConcept_multivaluedRef, _multivaluedRef, RemoveMultivaluedRefRaw);
		return this;
	}

	private ReferenceTarget? _singularRef = null;
	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If SingularRef has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(TinyRefLangLanguage), Key = "key-MyConcept-singularRef")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = false)]
	public INamed SingularRef { get => ReferenceTargetNonNullTarget<INamed>(_singularRef, TinyRefLangLanguage.Instance.MyConcept_singularRef) ?? throw new UnsetFeatureException(TinyRefLangLanguage.Instance.MyConcept_singularRef); set => SetSingularRef(value); }

	/// <remarks>Required Single Reference</remarks>
        public bool TryGetSingularRef([NotNullWhenAttribute(true)] out INamed? singularRef)
	{
		singularRef = ReferenceTargetNullableTarget<INamed>(_singularRef, TinyRefLangLanguage.Instance.MyConcept_singularRef);
		return singularRef != null;
	}

	private MyConcept SetSingularRef(ReferenceTarget? value)
	{
		SetRequiredSingleReference<INamed>(value, TinyRefLangLanguage.Instance.MyConcept_singularRef, _singularRef, SetSingularRefRaw);
		return this;
	}

	private bool SetSingularRefRaw(ReferenceTarget? value)
	{
		if (value == _singularRef)
			return false;
		_singularRef = value;
		return true;
	}

	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public MyConcept SetSingularRef(INamed value)
	{
		return SetSingularRef(ReferenceTarget.FromNodeOptional(value));
	}

	public MyConcept(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => TinyRefLangLanguage.Instance.MyConcept;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (_builtIns.INamed_name.EqualsIdentity(feature))
		{
			result = Name;
			return true;
		}

		if (TinyRefLangLanguage.Instance.MyConcept_multivaluedRef.EqualsIdentity(feature))
		{
			result = MultivaluedRef;
			return true;
		}

		if (TinyRefLangLanguage.Instance.MyConcept_singularRef.EqualsIdentity(feature))
		{
			result = SingularRef;
			return true;
		}

		return false;
	}

	protected override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (_builtIns.INamed_name.EqualsIdentity(feature))
		{
			result = _name;
			return true;
		}

		return false;
	}

	protected override bool TryGetReferenceRaw(Reference feature, out IReferenceTarget? result)
	{
		if (base.TryGetReferenceRaw(feature, out result))
			return true;
		if (TinyRefLangLanguage.Instance.MyConcept_singularRef.EqualsIdentity(feature))
		{
			result = _singularRef;
			return true;
		}

		return false;
	}

	protected override bool TryGetReferencesRaw(Reference feature, out IReadOnlyList<IReferenceTarget> result)
	{
		if (base.TryGetReferencesRaw(feature, out result))
			return true;
		if (TinyRefLangLanguage.Instance.MyConcept_multivaluedRef.EqualsIdentity(feature))
		{
			result = _multivaluedRef;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (_builtIns.INamed_name.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				SetName(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (TinyRefLangLanguage.Instance.MyConcept_multivaluedRef.EqualsIdentity(feature))
		{
			SetRequiredMultipleReference<INamed>(value, TinyRefLangLanguage.Instance.MyConcept_multivaluedRef, _multivaluedRef, SetMultivaluedRefRaw);
			return true;
		}

		if (TinyRefLangLanguage.Instance.MyConcept_singularRef.EqualsIdentity(feature))
		{
			if (value is INamed v)
			{
				SetSingularRef(v);
				return true;
			}

			if (value is ReferenceTarget target)
			{
				SetSingularRef(target);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (_builtIns.INamed_name.EqualsIdentity(feature) && value is null or string)
			return SetNameRaw((string?)value);
		return false;
	}

	protected override bool SetReferenceRaw(Reference feature, ReferenceTarget? value)
	{
		if (base.SetReferenceRaw(feature, value))
			return true;
		if (TinyRefLangLanguage.Instance.MyConcept_singularRef.EqualsIdentity(feature))
			return SetSingularRefRaw(value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetName(out _))
			result.Add(_builtIns.INamed_name);
		if (TryGetMultivaluedRef(out _))
			result.Add(TinyRefLangLanguage.Instance.MyConcept_multivaluedRef);
		if (TryGetSingularRef(out _))
			result.Add(TinyRefLangLanguage.Instance.MyConcept_singularRef);
		return result;
	}

	protected override bool AddReferencesRaw(Reference feature, ReferenceTarget value)
	{
		if (base.AddReferencesRaw(feature, value))
			return true;
		if (TinyRefLangLanguage.Instance.MyConcept_multivaluedRef.EqualsIdentity(feature))
			return AddMultivaluedRefRaw(value);
		return false;
	}

	protected override bool InsertReferencesRaw(Reference feature, int index, ReferenceTarget value)
	{
		if (base.InsertReferencesRaw(feature, index, value))
			return true;
		if (TinyRefLangLanguage.Instance.MyConcept_multivaluedRef.EqualsIdentity(feature))
			return InsertMultivaluedRefRaw(index, value);
		return false;
	}

	protected override bool RemoveReferencesRaw(Reference feature, ReferenceTarget value)
	{
		if (base.RemoveReferencesRaw(feature, value))
			return true;
		if (TinyRefLangLanguage.Instance.MyConcept_multivaluedRef.EqualsIdentity(feature))
			return RemoveMultivaluedRefRaw(value);
		return false;
	}

	/// <inheritdoc/>
        protected override bool AddInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.AddInternal(link, value))
			return true;
		if (TinyRefLangLanguage.Instance.MyConcept_multivaluedRef.EqualsIdentity(link))
		{
			AddMultivaluedRef(TinyRefLangLanguage.Instance.MyConcept_multivaluedRef.AsNodes<INamed>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool InsertInternal(Link? link, int index, IEnumerable<IReadableNode> value)
	{
		if (base.InsertInternal(link, index, value))
			return true;
		if (TinyRefLangLanguage.Instance.MyConcept_multivaluedRef.EqualsIdentity(link))
		{
			InsertMultivaluedRef(index, TinyRefLangLanguage.Instance.MyConcept_multivaluedRef.AsNodes<INamed>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool RemoveInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.RemoveInternal(link, value))
			return true;
		if (TinyRefLangLanguage.Instance.MyConcept_multivaluedRef.EqualsIdentity(link))
		{
			RemoveMultivaluedRef(TinyRefLangLanguage.Instance.MyConcept_multivaluedRef.AsNodes<INamed>(value));
			return true;
		}

		return false;
	}
}