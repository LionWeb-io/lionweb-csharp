// Generated by the C# M2TypesGenerator: modify at your own risk!
// ReSharper disable InconsistentNaming
// ReSharper disable SuggestVarOrType_SimpleTypes
// ReSharper disable SuggestVarOrType_Elsewhere
#pragma warning disable 1591
#nullable enable
namespace LionWeb.Core.Test.Languages.Generated.V2023_1.GeneralNodeLang;
using LionWeb.Core;
using LionWeb.Core.M2;
using LionWeb.Core.M3;
using LionWeb.Core.Notification;
using LionWeb.Core.Utilities;
using LionWeb.Core.VersionSpecific.V2023_1;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

[LionCoreLanguage(Key = "key-GeneralNodeLang", Version = "1")]
public partial class GeneralNodeLangLanguage : LanguageBase<IGeneralNodeLangFactory>
{
	public static readonly GeneralNodeLangLanguage Instance = new Lazy<GeneralNodeLangLanguage>(() => new("id-GeneralNodeLang")).Value;
	public GeneralNodeLangLanguage(string id) : base(id, LionWebVersions.v2023_1)
	{
		_generalNodeConcept = new(() => new ConceptBase<GeneralNodeLangLanguage>("id-GeneralNodeConcept", this) { Key = "key-GeneralNodeConcept", Name = "GeneralNodeConcept", Abstract = false, Partition = false, FeaturesLazy = new(() => [GeneralNodeConcept_multipleContainment, GeneralNodeConcept_multipleOptionalContainment, GeneralNodeConcept_multipleOptionalRef, GeneralNodeConcept_multipleRef, GeneralNodeConcept_singleContainment, GeneralNodeConcept_singleOptionalContainment, GeneralNodeConcept_singleOptionalRef, GeneralNodeConcept_singleRef]) });
		_generalNodeConcept_multipleContainment = new(() => new ContainmentBase<GeneralNodeLangLanguage>("id-multipleContainment", GeneralNodeConcept, this) { Key = "key-multipleContainment", Name = "multipleContainment", Optional = false, Multiple = true, Type = _builtIns.Node });
		_generalNodeConcept_multipleOptionalContainment = new(() => new ContainmentBase<GeneralNodeLangLanguage>("id-multipleOptionalContainment", GeneralNodeConcept, this) { Key = "key-multipleOptionalContainment", Name = "multipleOptionalContainment", Optional = true, Multiple = true, Type = _builtIns.Node });
		_generalNodeConcept_multipleOptionalRef = new(() => new ReferenceBase<GeneralNodeLangLanguage>("id-multipleOptionalRef", GeneralNodeConcept, this) { Key = "key-multipleOptionalRef", Name = "multipleOptionalRef", Optional = true, Multiple = true, Type = _builtIns.Node });
		_generalNodeConcept_multipleRef = new(() => new ReferenceBase<GeneralNodeLangLanguage>("id-multipleRef", GeneralNodeConcept, this) { Key = "key-multipleRef", Name = "multipleRef", Optional = false, Multiple = true, Type = _builtIns.Node });
		_generalNodeConcept_singleContainment = new(() => new ContainmentBase<GeneralNodeLangLanguage>("id-singleContainment", GeneralNodeConcept, this) { Key = "key-singleContainment", Name = "singleContainment", Optional = false, Multiple = false, Type = _builtIns.Node });
		_generalNodeConcept_singleOptionalContainment = new(() => new ContainmentBase<GeneralNodeLangLanguage>("id-singleOptionalContainment", GeneralNodeConcept, this) { Key = "key-singleOptionalContainment", Name = "singleOptionalContainment", Optional = true, Multiple = false, Type = _builtIns.Node });
		_generalNodeConcept_singleOptionalRef = new(() => new ReferenceBase<GeneralNodeLangLanguage>("id-singleOptionalRef", GeneralNodeConcept, this) { Key = "key-singleOptionalRef", Name = "singleOptionalRef", Optional = true, Multiple = false, Type = _builtIns.Node });
		_generalNodeConcept_singleRef = new(() => new ReferenceBase<GeneralNodeLangLanguage>("id-singleRef", GeneralNodeConcept, this) { Key = "key-singleRef", Name = "singleRef", Optional = false, Multiple = false, Type = _builtIns.Node });
		_factory = new GeneralNodeLangFactory(this);
	}

	/// <inheritdoc/>
        public override IReadOnlyList<LanguageEntity> Entities => [GeneralNodeConcept];
	/// <inheritdoc/>
        public override IReadOnlyList<Language> DependsOn => [];

	private const string _key = "key-GeneralNodeLang";
	/// <inheritdoc/>
        public override string Key => _key;

	private const string _name = "GeneralNodeLang";
	/// <inheritdoc/>
        public override string Name => _name;

	private const string _version = "1";
	/// <inheritdoc/>
        public override string Version => _version;

	private readonly Lazy<Concept> _generalNodeConcept;
	public Concept GeneralNodeConcept => _generalNodeConcept.Value;

	private readonly Lazy<Containment> _generalNodeConcept_multipleContainment;
	public Containment GeneralNodeConcept_multipleContainment => _generalNodeConcept_multipleContainment.Value;

	private readonly Lazy<Containment> _generalNodeConcept_multipleOptionalContainment;
	public Containment GeneralNodeConcept_multipleOptionalContainment => _generalNodeConcept_multipleOptionalContainment.Value;

	private readonly Lazy<Reference> _generalNodeConcept_multipleOptionalRef;
	public Reference GeneralNodeConcept_multipleOptionalRef => _generalNodeConcept_multipleOptionalRef.Value;

	private readonly Lazy<Reference> _generalNodeConcept_multipleRef;
	public Reference GeneralNodeConcept_multipleRef => _generalNodeConcept_multipleRef.Value;

	private readonly Lazy<Containment> _generalNodeConcept_singleContainment;
	public Containment GeneralNodeConcept_singleContainment => _generalNodeConcept_singleContainment.Value;

	private readonly Lazy<Containment> _generalNodeConcept_singleOptionalContainment;
	public Containment GeneralNodeConcept_singleOptionalContainment => _generalNodeConcept_singleOptionalContainment.Value;

	private readonly Lazy<Reference> _generalNodeConcept_singleOptionalRef;
	public Reference GeneralNodeConcept_singleOptionalRef => _generalNodeConcept_singleOptionalRef.Value;

	private readonly Lazy<Reference> _generalNodeConcept_singleRef;
	public Reference GeneralNodeConcept_singleRef => _generalNodeConcept_singleRef.Value;
}

public partial interface IGeneralNodeLangFactory : INodeFactory
{
	public GeneralNodeConcept NewGeneralNodeConcept(string id);
	public GeneralNodeConcept CreateGeneralNodeConcept();
}

public class GeneralNodeLangFactory : AbstractBaseNodeFactory, IGeneralNodeLangFactory
{
	private readonly GeneralNodeLangLanguage _language;
	public GeneralNodeLangFactory(GeneralNodeLangLanguage language) : base(language)
	{
		_language = language;
	}

	/// <inheritdoc/>
        public override INode CreateNode(string id, Classifier classifier)
	{
		if (_language.GeneralNodeConcept.EqualsIdentity(classifier))
			return NewGeneralNodeConcept(id);
		throw new UnsupportedClassifierException(classifier);
	}

	/// <inheritdoc/>
        public override Enum GetEnumerationLiteral(EnumerationLiteral literal)
	{
		throw new UnsupportedEnumerationLiteralException(literal);
	}

	/// <inheritdoc/>
        public override IStructuredDataTypeInstance CreateStructuredDataTypeInstance(StructuredDataType structuredDataType, IFieldValues fieldValues)
	{
		throw new UnsupportedStructuredDataTypeException(structuredDataType);
	}

	public virtual GeneralNodeConcept NewGeneralNodeConcept(string id) => new(id);
	public virtual GeneralNodeConcept CreateGeneralNodeConcept() => NewGeneralNodeConcept(GetNewId());
}

[LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-GeneralNodeConcept")]
public partial class GeneralNodeConcept : ConceptInstanceBase
{
	private bool SetMultipleContainmentRaw(List<INode> nodes) => ExchangeChildrenRaw(nodes, _multipleContainment);
	private bool AddMultipleContainmentRaw(INode? value) => AddChildRaw(value, _multipleContainment);
	private bool InsertMultipleContainmentRaw(int index, INode? value) => InsertChildRaw(index, value, _multipleContainment);
	private bool RemoveMultipleContainmentRaw(INode? value) => RemoveChildRaw(value, _multipleContainment);
	private readonly List<INode> _multipleContainment = [];
	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If MultipleContainment is empty</exception>
        [LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-multipleContainment")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = true)]
	public IReadOnlyList<INode> MultipleContainment { get => AsNonEmptyReadOnly(_multipleContainment, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment); init => AddMultipleContainment(value); }

	/// <remarks>Required Multiple Containment</remarks>
        public bool TryGetMultipleContainment([NotNullWhenAttribute(true)] out IReadOnlyList<IReadableNode> multipleContainment)
	{
		multipleContainment = _multipleContainment.AsReadOnly();
		return multipleContainment.Count != 0;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If both MultipleContainment and nodes are empty</exception>
        public GeneralNodeConcept AddMultipleContainment(IEnumerable<INode> nodes)
	{
		AddRequiredMultipleContainment<INode>(nodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment, _multipleContainment, AddMultipleContainmentRaw);
		return this;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If both MultipleContainment and nodes are empty</exception>
    	/// <exception cref = "ArgumentOutOfRangeException">If index negative or greater than MultipleContainment.Count</exception>
        public GeneralNodeConcept InsertMultipleContainment(int index, IEnumerable<INode> nodes)
	{
		InsertRequiredMultipleContainment<INode>(index, nodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment, _multipleContainment, InsertMultipleContainmentRaw);
		return this;
	}

	/// <remarks>Required Multiple Containment</remarks>
    	/// <exception cref = "InvalidValueException">If MultipleContainment would be empty</exception>
        public GeneralNodeConcept RemoveMultipleContainment(IEnumerable<INode> nodes)
	{
		RemoveRequiredMultipleContainment<INode>(nodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment, _multipleContainment, RemoveMultipleContainmentRaw);
		return this;
	}

	private bool SetMultipleOptionalContainmentRaw(List<INode> nodes) => ExchangeChildrenRaw(nodes, _multipleOptionalContainment);
	private bool AddMultipleOptionalContainmentRaw(INode? value) => AddChildRaw(value, _multipleOptionalContainment);
	private bool InsertMultipleOptionalContainmentRaw(int index, INode? value) => InsertChildRaw(index, value, _multipleOptionalContainment);
	private bool RemoveMultipleOptionalContainmentRaw(INode? value) => RemoveChildRaw(value, _multipleOptionalContainment);
	private readonly List<INode> _multipleOptionalContainment = [];
	/// <remarks>Optional Multiple Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-multipleOptionalContainment")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = true)]
	public IReadOnlyList<INode> MultipleOptionalContainment { get => _multipleOptionalContainment.AsReadOnly(); init => AddMultipleOptionalContainment(value); }

	/// <remarks>Optional Multiple Containment</remarks>
        public bool TryGetMultipleOptionalContainment([NotNullWhenAttribute(true)] out IReadOnlyList<IReadableNode> multipleOptionalContainment)
	{
		multipleOptionalContainment = _multipleOptionalContainment.AsReadOnly();
		return multipleOptionalContainment.Count != 0;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public GeneralNodeConcept AddMultipleOptionalContainment(IEnumerable<INode> nodes)
	{
		AddOptionalMultipleContainment<INode>(nodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment, _multipleOptionalContainment, AddMultipleOptionalContainmentRaw);
		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public GeneralNodeConcept InsertMultipleOptionalContainment(int index, IEnumerable<INode> nodes)
	{
		InsertOptionalMultipleContainment<INode>(index, nodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment, _multipleOptionalContainment, InsertMultipleOptionalContainmentRaw);
		return this;
	}

	/// <remarks>Optional Multiple Containment</remarks>
        public GeneralNodeConcept RemoveMultipleOptionalContainment(IEnumerable<INode> nodes)
	{
		RemoveOptionalMultipleContainment<INode>(nodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment, _multipleOptionalContainment, RemoveMultipleOptionalContainmentRaw);
		return this;
	}

	private readonly List<ReferenceTarget> _multipleOptionalRef = [];
	/// <remarks>Optional Multiple Reference</remarks>
        [LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-multipleOptionalRef")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = true, Multiple = true)]
	public IReadOnlyList<IReadableNode> MultipleOptionalRef { get => ReferenceTargetNonNullTargets<IReadableNode>(_multipleOptionalRef, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef); init => AddMultipleOptionalRef(value); }

	/// <remarks>Optional Multiple Reference</remarks>
        public bool TryGetMultipleOptionalRef([NotNullWhenAttribute(true)] out IReadOnlyList<IReadableNode> multipleOptionalRef) => TryGetReference<IReadableNode>(_multipleOptionalRef, out multipleOptionalRef);
	private bool SetMultipleOptionalRefRaw(List<ReferenceTarget> targets) => SetReferencesRaw(targets, _multipleOptionalRef);
	private bool AddMultipleOptionalRefRaw(ReferenceTarget target) => AddReferencesRaw(target, _multipleOptionalRef);
	private bool InsertMultipleOptionalRefRaw(int index, ReferenceTarget target) => InsertReferencesRaw(index, target, _multipleOptionalRef);
	private bool RemoveMultipleOptionalRefRaw(ReferenceTarget target) => RemoveReferencesRaw(target, _multipleOptionalRef);
	/// <remarks>Optional Multiple Reference</remarks>
        public GeneralNodeConcept AddMultipleOptionalRef(IEnumerable<IReadableNode> nodes)
	{
		AddOptionalMultipleReference<IReadableNode>(nodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef, _multipleOptionalRef, AddMultipleOptionalRefRaw);
		return this;
	}

	/// <remarks>Optional Multiple Reference</remarks>
        public GeneralNodeConcept InsertMultipleOptionalRef(int index, IEnumerable<IReadableNode> nodes)
	{
		InsertOptionalMultipleReference<IReadableNode>(index, nodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef, _multipleOptionalRef, InsertMultipleOptionalRefRaw);
		return this;
	}

	/// <remarks>Optional Multiple Reference</remarks>
        public GeneralNodeConcept RemoveMultipleOptionalRef(IEnumerable<IReadableNode> nodes)
	{
		RemoveOptionalMultipleReference<IReadableNode>(nodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef, _multipleOptionalRef, RemoveMultipleOptionalRefRaw);
		return this;
	}

	private readonly List<ReferenceTarget> _multipleRef = [];
	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If MultipleRef is empty</exception>
        [LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-multipleRef")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = true)]
	public IReadOnlyList<IReadableNode> MultipleRef { get => GetRequiredNonNullReferences<IReadableNode>(_multipleRef, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef); init => AddMultipleRef(value); }

	/// <remarks>Required Multiple Reference</remarks>
        public bool TryGetMultipleRef([NotNullWhenAttribute(true)] out IReadOnlyList<IReadableNode> multipleRef) => TryGetReference<IReadableNode>(_multipleRef, out multipleRef);
	private bool SetMultipleRefRaw(List<ReferenceTarget> targets) => SetReferencesRaw(targets, _multipleRef);
	private bool AddMultipleRefRaw(ReferenceTarget target) => AddReferencesRaw(target, _multipleRef);
	private bool InsertMultipleRefRaw(int index, ReferenceTarget target) => InsertReferencesRaw(index, target, _multipleRef);
	private bool RemoveMultipleRefRaw(ReferenceTarget target) => RemoveReferencesRaw(target, _multipleRef);
	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If both MultipleRef and nodes are empty</exception>
        public GeneralNodeConcept AddMultipleRef(IEnumerable<IReadableNode> nodes)
	{
		AddRequiredMultipleReference<IReadableNode>(nodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef, _multipleRef, AddMultipleRefRaw);
		return this;
	}

	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If both MultipleRef and nodes are empty</exception>
    	/// <exception cref = "ArgumentOutOfRangeException">If index negative or greater than MultipleRef.Count</exception>
        public GeneralNodeConcept InsertMultipleRef(int index, IEnumerable<IReadableNode> nodes)
	{
		InsertRequiredMultipleReference<IReadableNode>(index, nodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef, _multipleRef, InsertMultipleRefRaw);
		return this;
	}

	/// <remarks>Required Multiple Reference</remarks>
    	/// <exception cref = "InvalidValueException">If MultipleRef would be empty</exception>
        public GeneralNodeConcept RemoveMultipleRef(IEnumerable<IReadableNode> nodes)
	{
		RemoveRequiredMultipleReference<IReadableNode>(nodes, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef, _multipleRef, RemoveMultipleRefRaw);
		return this;
	}

	private INode? _singleContainment = null;
	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If SingleContainment has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-singleContainment")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = false)]
	public INode SingleContainment { get => _singleContainment ?? throw new UnsetFeatureException(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment); set => SetSingleContainment(value); }

	/// <remarks>Required Single Containment</remarks>
        public bool TryGetSingleContainment([NotNullWhenAttribute(true)] out INode? singleContainment)
	{
		singleContainment = _singleContainment;
		return singleContainment != null;
	}

	private bool SetSingleContainmentRaw(INode? value)
	{
		if (!ExchangeChildRaw(value, _singleContainment))
			return false;
		_singleContainment = value;
		return true;
	}

	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public GeneralNodeConcept SetSingleContainment(INode value)
	{
		SetRequiredSingleContainment<INode>(value, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment, _singleContainment, SetSingleContainmentRaw);
		return this;
	}

	private INode? _singleOptionalContainment = null;
	/// <remarks>Optional Single Containment</remarks>
        [LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-singleOptionalContainment")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = true, Multiple = false)]
	public INode? SingleOptionalContainment { get => _singleOptionalContainment; set => SetSingleOptionalContainment(value); }

	/// <remarks>Optional Single Containment</remarks>
        public bool TryGetSingleOptionalContainment([NotNullWhenAttribute(true)] out INode? singleOptionalContainment)
	{
		singleOptionalContainment = _singleOptionalContainment;
		return singleOptionalContainment != null;
	}

	private bool SetSingleOptionalContainmentRaw(INode? value)
	{
		if (!ExchangeChildRaw(value, _singleOptionalContainment))
			return false;
		_singleOptionalContainment = value;
		return true;
	}

	/// <remarks>Optional Single Containment</remarks>
        public GeneralNodeConcept SetSingleOptionalContainment(INode? value)
	{
		SetOptionalSingleContainment<INode>(value, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalContainment, _singleOptionalContainment, SetSingleOptionalContainmentRaw);
		return this;
	}

	private ReferenceTarget? _singleOptionalRef = null;
	/// <remarks>Optional Single Reference</remarks>
        [LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-singleOptionalRef")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = true, Multiple = false)]
	public IReadableNode? SingleOptionalRef { get => ReferenceTargetNonNullTarget<IReadableNode>(_singleOptionalRef, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalRef); set => SetSingleOptionalRef(value); }

	/// <remarks>Optional Single Reference</remarks>
        public bool TryGetSingleOptionalRef([NotNullWhenAttribute(true)] out IReadableNode? singleOptionalRef)
	{
		singleOptionalRef = ReferenceTargetNullableTarget<IReadableNode>(_singleOptionalRef, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalRef);
		return singleOptionalRef != null;
	}

	private GeneralNodeConcept SetSingleOptionalRef(ReferenceTarget? value)
	{
		SetOptionalSingleReference<IReadableNode>(value, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalRef, _singleOptionalRef, SetSingleOptionalRefRaw);
		return this;
	}

	private bool SetSingleOptionalRefRaw(ReferenceTarget? value)
	{
		if (value == _singleOptionalRef)
			return false;
		_singleOptionalRef = value;
		return true;
	}

	/// <remarks>Optional Single Reference</remarks>
        public GeneralNodeConcept SetSingleOptionalRef(IReadableNode? value)
	{
		return SetSingleOptionalRef(ReferenceTarget.FromNodeOptional(value));
	}

	private ReferenceTarget? _singleRef = null;
	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If SingleRef has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(GeneralNodeLangLanguage), Key = "key-singleRef")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = false)]
	public IReadableNode SingleRef { get => ReferenceTargetNonNullTarget<IReadableNode>(_singleRef, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef) ?? throw new UnsetFeatureException(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef); set => SetSingleRef(value); }

	/// <remarks>Required Single Reference</remarks>
        public bool TryGetSingleRef([NotNullWhenAttribute(true)] out IReadableNode? singleRef)
	{
		singleRef = ReferenceTargetNullableTarget<IReadableNode>(_singleRef, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef);
		return singleRef != null;
	}

	private GeneralNodeConcept SetSingleRef(ReferenceTarget? value)
	{
		SetRequiredSingleReference<IReadableNode>(value, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef, _singleRef, SetSingleRefRaw);
		return this;
	}

	private bool SetSingleRefRaw(ReferenceTarget? value)
	{
		if (value == _singleRef)
			return false;
		_singleRef = value;
		return true;
	}

	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public GeneralNodeConcept SetSingleRef(IReadableNode value)
	{
		return SetSingleRef(ReferenceTarget.FromNodeOptional(value));
	}

	public GeneralNodeConcept(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => GeneralNodeLangLanguage.Instance.GeneralNodeConcept;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(feature))
		{
			result = MultipleContainment;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.EqualsIdentity(feature))
		{
			result = MultipleOptionalContainment;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef.EqualsIdentity(feature))
		{
			result = MultipleOptionalRef;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.EqualsIdentity(feature))
		{
			result = MultipleRef;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment.EqualsIdentity(feature))
		{
			result = SingleContainment;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalContainment.EqualsIdentity(feature))
		{
			result = SingleOptionalContainment;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalRef.EqualsIdentity(feature))
		{
			result = SingleOptionalRef;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef.EqualsIdentity(feature))
		{
			result = SingleRef;
			return true;
		}

		return false;
	}

	protected override bool TryGetContainmentRaw(Containment feature, out IReadableNode? result)
	{
		if (base.TryGetContainmentRaw(feature, out result))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment.EqualsIdentity(feature))
		{
			result = _singleContainment;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalContainment.EqualsIdentity(feature))
		{
			result = _singleOptionalContainment;
			return true;
		}

		return false;
	}

	protected override bool TryGetContainmentsRaw(Containment feature, out IReadOnlyList<IReadableNode> result)
	{
		if (base.TryGetContainmentsRaw(feature, out result))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(feature))
		{
			result = _multipleContainment;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.EqualsIdentity(feature))
		{
			result = _multipleOptionalContainment;
			return true;
		}

		return false;
	}

	protected override bool TryGetReferenceRaw(Reference feature, out IReferenceTarget? result)
	{
		if (base.TryGetReferenceRaw(feature, out result))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalRef.EqualsIdentity(feature))
		{
			result = _singleOptionalRef;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef.EqualsIdentity(feature))
		{
			result = _singleRef;
			return true;
		}

		return false;
	}

	protected override bool TryGetReferencesRaw(Reference feature, out IReadOnlyList<IReferenceTarget> result)
	{
		if (base.TryGetReferencesRaw(feature, out result))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef.EqualsIdentity(feature))
		{
			result = _multipleOptionalRef;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.EqualsIdentity(feature))
		{
			result = _multipleRef;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(feature))
		{
			SetRequiredMultipleContainment<INode>(value, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment, _multipleContainment, SetMultipleContainmentRaw);
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.EqualsIdentity(feature))
		{
			SetOptionalMultipleContainment<INode>(value, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment, _multipleOptionalContainment, SetMultipleOptionalContainmentRaw);
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef.EqualsIdentity(feature))
		{
			SetOptionalMultipleReference<IReadableNode>(value, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef, _multipleOptionalRef, SetMultipleOptionalRefRaw);
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.EqualsIdentity(feature))
		{
			SetRequiredMultipleReference<IReadableNode>(value, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef, _multipleRef, SetMultipleRefRaw);
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment.EqualsIdentity(feature))
		{
			if (value is INode v)
			{
				SetSingleContainment(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalContainment.EqualsIdentity(feature))
		{
			if (value is null or INode)
			{
				SetSingleOptionalContainment((INode?)value);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalRef.EqualsIdentity(feature))
		{
			if (value is null or IReadableNode)
			{
				SetSingleOptionalRef((IReadableNode?)value);
				return true;
			}

			if (value is ReferenceTarget target)
			{
				SetSingleOptionalRef(target);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef.EqualsIdentity(feature))
		{
			if (value is IReadableNode v)
			{
				SetSingleRef(v);
				return true;
			}

			if (value is ReferenceTarget target)
			{
				SetSingleRef(target);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected override bool SetContainmentRaw(Containment feature, IWritableNode? value)
	{
		if (base.SetContainmentRaw(feature, value))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment.EqualsIdentity(feature) && value is null or INode)
			return SetSingleContainmentRaw((INode?)value);
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalContainment.EqualsIdentity(feature) && value is null or INode)
			return SetSingleOptionalContainmentRaw((INode?)value);
		return false;
	}

	protected override bool SetReferenceRaw(Reference feature, ReferenceTarget? value)
	{
		if (base.SetReferenceRaw(feature, value))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalRef.EqualsIdentity(feature))
			return SetSingleOptionalRefRaw(value);
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef.EqualsIdentity(feature))
			return SetSingleRefRaw(value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetMultipleContainment(out _))
			result.Add(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment);
		if (TryGetMultipleOptionalContainment(out _))
			result.Add(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment);
		if (TryGetMultipleOptionalRef(out _))
			result.Add(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef);
		if (TryGetMultipleRef(out _))
			result.Add(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef);
		if (TryGetSingleContainment(out _))
			result.Add(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment);
		if (TryGetSingleOptionalContainment(out _))
			result.Add(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalContainment);
		if (TryGetSingleOptionalRef(out _))
			result.Add(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalRef);
		if (TryGetSingleRef(out _))
			result.Add(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleRef);
		return result;
	}

	protected override bool AddContainmentsRaw(Containment feature, IWritableNode value)
	{
		if (base.AddContainmentsRaw(feature, value))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(feature) && value is INode v0)
			return AddMultipleContainmentRaw(v0);
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.EqualsIdentity(feature) && value is INode v1)
			return AddMultipleOptionalContainmentRaw(v1);
		return false;
	}

	protected override bool AddReferencesRaw(Reference feature, ReferenceTarget value)
	{
		if (base.AddReferencesRaw(feature, value))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef.EqualsIdentity(feature))
			return AddMultipleOptionalRefRaw(value);
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.EqualsIdentity(feature))
			return AddMultipleRefRaw(value);
		return false;
	}

	protected override bool InsertContainmentsRaw(Containment feature, int index, IWritableNode value)
	{
		if (base.InsertContainmentsRaw(feature, index, value))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(feature) && value is INode v0)
			return InsertMultipleContainmentRaw(index, v0);
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.EqualsIdentity(feature) && value is INode v1)
			return InsertMultipleOptionalContainmentRaw(index, v1);
		return false;
	}

	protected override bool InsertReferencesRaw(Reference feature, int index, ReferenceTarget value)
	{
		if (base.InsertReferencesRaw(feature, index, value))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef.EqualsIdentity(feature))
			return InsertMultipleOptionalRefRaw(index, value);
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.EqualsIdentity(feature))
			return InsertMultipleRefRaw(index, value);
		return false;
	}

	protected override bool RemoveContainmentsRaw(Containment feature, IWritableNode value)
	{
		if (base.RemoveContainmentsRaw(feature, value))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(feature) && value is INode v0)
			return RemoveMultipleContainmentRaw(v0);
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.EqualsIdentity(feature) && value is INode v1)
			return RemoveMultipleOptionalContainmentRaw(v1);
		return false;
	}

	protected override bool RemoveReferencesRaw(Reference feature, ReferenceTarget value)
	{
		if (base.RemoveReferencesRaw(feature, value))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef.EqualsIdentity(feature))
			return RemoveMultipleOptionalRefRaw(value);
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.EqualsIdentity(feature))
			return RemoveMultipleRefRaw(value);
		return false;
	}

	/// <inheritdoc/>
        protected override bool AddInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.AddInternal(link, value))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(link))
		{
			AddMultipleContainment(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.AsNodes<INode>(value));
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.EqualsIdentity(link))
		{
			AddMultipleOptionalContainment(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.AsNodes<INode>(value));
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef.EqualsIdentity(link))
		{
			AddMultipleOptionalRef(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef.AsNodes<IReadableNode>(value));
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.EqualsIdentity(link))
		{
			AddMultipleRef(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.AsNodes<IReadableNode>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool InsertInternal(Link? link, int index, IEnumerable<IReadableNode> value)
	{
		if (base.InsertInternal(link, index, value))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(link))
		{
			InsertMultipleContainment(index, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.AsNodes<INode>(value));
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.EqualsIdentity(link))
		{
			InsertMultipleOptionalContainment(index, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.AsNodes<INode>(value));
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef.EqualsIdentity(link))
		{
			InsertMultipleOptionalRef(index, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef.AsNodes<IReadableNode>(value));
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.EqualsIdentity(link))
		{
			InsertMultipleRef(index, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.AsNodes<IReadableNode>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool RemoveInternal(Link? link, IEnumerable<IReadableNode> value)
	{
		if (base.RemoveInternal(link, value))
			return true;
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(link))
		{
			RemoveMultipleContainment(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.AsNodes<INode>(value));
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.EqualsIdentity(link))
		{
			RemoveMultipleOptionalContainment(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.AsNodes<INode>(value));
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef.EqualsIdentity(link))
		{
			RemoveMultipleOptionalRef(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalRef.AsNodes<IReadableNode>(value));
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.EqualsIdentity(link))
		{
			RemoveMultipleRef(GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleRef.AsNodes<IReadableNode>(value));
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _multipleContainment, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment);
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment.EqualsIdentity(c))
		{
			RemoveSelfParent(child, _multipleOptionalContainment, GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment);
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment.EqualsIdentity(c))
		{
			_singleContainment = null;
			return true;
		}

		if (GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalContainment.EqualsIdentity(c))
		{
			_singleOptionalContainment = null;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (child is IReadableNode child0 && _multipleContainment.Contains(child0))
			return GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleContainment;
		if (child is IReadableNode child1 && _multipleOptionalContainment.Contains(child1))
			return GeneralNodeLangLanguage.Instance.GeneralNodeConcept_multipleOptionalContainment;
		if (ReferenceEquals(_singleContainment, child))
			return GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleContainment;
		if (ReferenceEquals(_singleOptionalContainment, child))
			return GeneralNodeLangLanguage.Instance.GeneralNodeConcept_singleOptionalContainment;
		return null;
	}
}