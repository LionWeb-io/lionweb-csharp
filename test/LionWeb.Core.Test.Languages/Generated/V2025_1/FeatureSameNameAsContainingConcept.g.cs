// Generated by the C# M2TypesGenerator: modify at your own risk!
// ReSharper disable InconsistentNaming
// ReSharper disable SuggestVarOrType_SimpleTypes
// ReSharper disable SuggestVarOrType_Elsewhere
#pragma warning disable 1591
#nullable enable
namespace LionWeb.Core.Test.Languages.Generated.V2025_1.FeatureSameNameAsContainingConcept;
using global::LionWeb.Core;
using global::LionWeb.Core.M2;
using global::LionWeb.Core.M3;
using global::LionWeb.Core.Notification;
using global::LionWeb.Core.Utilities;
using global::LionWeb.Core.VersionSpecific.V2025_1;
using global::System;
using global::System.Collections.Generic;
using global::System.Diagnostics.CodeAnalysis;

[LionCoreLanguage(Key = "key-FeatureSameNameAsContainingConcept", Version = "1")]
public partial class FeatureSameNameAsContainingConceptLanguage : LanguageBase<IFeatureSameNameAsContainingConceptFactory>
{
	public static readonly FeatureSameNameAsContainingConceptLanguage Instance = new Lazy<FeatureSameNameAsContainingConceptLanguage>(() => new("id-FeatureSameNameAsContainingConcept-lang")).Value;
	public FeatureSameNameAsContainingConceptLanguage(string id) : base(id, LionWebVersions.v2025_1)
	{
		_baseConceptA = new(() => new ConceptBase<FeatureSameNameAsContainingConceptLanguage>("id-BaseConceptA", this) { Key = "key-BaseConceptA", Name = "BaseConceptA", Abstract = true, Partition = false, FeaturesLazy = new(() => [BaseConceptA_BaseConceptA]) });
		_baseConceptA_BaseConceptA = new(() => new PropertyBase<FeatureSameNameAsContainingConceptLanguage>("id-BaseConceptA", BaseConceptA, this) { Key = "key-BaseConceptA", Name = "BaseConceptA", Optional = false, Type = _builtIns.String });
		_baseConceptB = new(() => new ConceptBase<FeatureSameNameAsContainingConceptLanguage>("id-BaseConceptB", this) { Key = "key-BaseConceptB", Name = "BaseConceptB", Abstract = true, Partition = false, FeaturesLazy = new(() => [BaseConceptB_SubConceptB]) });
		_baseConceptB_SubConceptB = new(() => new PropertyBase<FeatureSameNameAsContainingConceptLanguage>("id-SubConceptB", BaseConceptB, this) { Key = "key-SubConceptB", Name = "SubConceptB", Optional = false, Type = _builtIns.String });
		_baseConceptC = new(() => new ConceptBase<FeatureSameNameAsContainingConceptLanguage>("id-BaseConceptC", this) { Key = "key-BaseConceptC", Name = "BaseConceptC", Abstract = true, Partition = false, FeaturesLazy = new(() => [BaseConceptC_BaseConceptD]) });
		_baseConceptC_BaseConceptD = new(() => new PropertyBase<FeatureSameNameAsContainingConceptLanguage>("id-BaseConceptD", BaseConceptC, this) { Key = "key-BaseConceptD", Name = "BaseConceptD", Optional = false, Type = _builtIns.String });
		_baseConceptD = new(() => new ConceptBase<FeatureSameNameAsContainingConceptLanguage>("id-BaseConceptD", this) { Key = "key-BaseConceptD", Name = "BaseConceptD", Abstract = true, Partition = false, FeaturesLazy = new(() => [BaseConceptD_BaseConceptE]) });
		_baseConceptD_BaseConceptE = new(() => new PropertyBase<FeatureSameNameAsContainingConceptLanguage>("id-BaseConceptE", BaseConceptD, this) { Key = "key-BaseConceptE", Name = "BaseConceptE", Optional = false, Type = _builtIns.String });
		_iface = new(() => new InterfaceBase<FeatureSameNameAsContainingConceptLanguage>("id-Iface", this) { Key = "key-Iface", Name = "Iface", FeaturesLazy = new(() => [Iface_IfaceMethod]) });
		_iface_IfaceMethod = new(() => new PropertyBase<FeatureSameNameAsContainingConceptLanguage>("id-IfaceMethod", Iface, this) { Key = "key-IfaceMethod", Name = "IfaceMethod", Optional = false, Type = _builtIns.String });
		_ifaceImplA = new(() => new ConceptBase<FeatureSameNameAsContainingConceptLanguage>("id-IfaceImplA", this) { Key = "key-IfaceImplA", Name = "IfaceImplA", Abstract = false, Partition = false, ImplementsLazy = new(() => [Iface]) });
		_ifaceImplB = new(() => new ConceptBase<FeatureSameNameAsContainingConceptLanguage>("id-IfaceImplB", this) { Key = "key-IfaceImplB", Name = "IfaceImplB", Abstract = false, Partition = false, ImplementsLazy = new(() => [Iface]) });
		_ifaceMethod = new(() => new ConceptBase<FeatureSameNameAsContainingConceptLanguage>("id-IfaceMethod", this) { Key = "key-IfaceMethod", Name = "IfaceMethod", Abstract = false, Partition = false, ExtendsLazy = new(() => IfaceImplA) });
		_subConceptA = new(() => new ConceptBase<FeatureSameNameAsContainingConceptLanguage>("id-SubConceptA", this) { Key = "key-SubConceptA", Name = "SubConceptA", Abstract = false, Partition = false, ExtendsLazy = new(() => BaseConceptA) });
		_subConceptB = new(() => new ConceptBase<FeatureSameNameAsContainingConceptLanguage>("id-SubConceptB", this) { Key = "key-SubConceptB", Name = "SubConceptB", Abstract = false, Partition = false, ExtendsLazy = new(() => BaseConceptB) });
		_factory = new FeatureSameNameAsContainingConceptFactory(this);
	}

	/// <inheritdoc/>
        public override IReadOnlyList<LanguageEntity> Entities => [BaseConceptA, BaseConceptB, BaseConceptC, BaseConceptD, Iface, IfaceImplA, IfaceImplB, IfaceMethod, SubConceptA, SubConceptB];
	/// <inheritdoc/>
        public override IReadOnlyList<Language> DependsOn => [];

	private const string _key = "key-FeatureSameNameAsContainingConcept";
	/// <inheritdoc/>
        public override string Key => _key;

	private const string _name = "FeatureSameNameAsContainingConcept";
	/// <inheritdoc/>
        public override string Name => _name;

	private const string _version = "1";
	/// <inheritdoc/>
        public override string Version => _version;

	private readonly Lazy<Concept> _baseConceptA;
	public Concept BaseConceptA => _baseConceptA.Value;

	private readonly Lazy<Property> _baseConceptA_BaseConceptA;
	public Property BaseConceptA_BaseConceptA => _baseConceptA_BaseConceptA.Value;

	private readonly Lazy<Concept> _baseConceptB;
	public Concept BaseConceptB => _baseConceptB.Value;

	private readonly Lazy<Property> _baseConceptB_SubConceptB;
	public Property BaseConceptB_SubConceptB => _baseConceptB_SubConceptB.Value;

	private readonly Lazy<Concept> _baseConceptC;
	public Concept BaseConceptC => _baseConceptC.Value;

	private readonly Lazy<Property> _baseConceptC_BaseConceptD;
	public Property BaseConceptC_BaseConceptD => _baseConceptC_BaseConceptD.Value;

	private readonly Lazy<Concept> _baseConceptD;
	public Concept BaseConceptD => _baseConceptD.Value;

	private readonly Lazy<Property> _baseConceptD_BaseConceptE;
	public Property BaseConceptD_BaseConceptE => _baseConceptD_BaseConceptE.Value;

	private readonly Lazy<Interface> _iface;
	public Interface Iface => _iface.Value;

	private readonly Lazy<Property> _iface_IfaceMethod;
	public Property Iface_IfaceMethod => _iface_IfaceMethod.Value;

	private readonly Lazy<Concept> _ifaceImplA;
	public Concept IfaceImplA => _ifaceImplA.Value;

	private readonly Lazy<Concept> _ifaceImplB;
	public Concept IfaceImplB => _ifaceImplB.Value;

	private readonly Lazy<Concept> _ifaceMethod;
	public Concept IfaceMethod => _ifaceMethod.Value;

	private readonly Lazy<Concept> _subConceptA;
	public Concept SubConceptA => _subConceptA.Value;

	private readonly Lazy<Concept> _subConceptB;
	public Concept SubConceptB => _subConceptB.Value;
}

public partial interface IFeatureSameNameAsContainingConceptFactory : INodeFactory
{
	public IfaceImplA NewIfaceImplA(string id);
	public IfaceImplA CreateIfaceImplA();
	public IfaceImplB NewIfaceImplB(string id);
	public IfaceImplB CreateIfaceImplB();
	public IfaceMethod NewIfaceMethod(string id);
	public IfaceMethod CreateIfaceMethod();
	public SubConceptA NewSubConceptA(string id);
	public SubConceptA CreateSubConceptA();
	public SubConceptB NewSubConceptB(string id);
	public SubConceptB CreateSubConceptB();
}

public class FeatureSameNameAsContainingConceptFactory : AbstractBaseNodeFactory, IFeatureSameNameAsContainingConceptFactory
{
	private readonly FeatureSameNameAsContainingConceptLanguage _language;
	public FeatureSameNameAsContainingConceptFactory(FeatureSameNameAsContainingConceptLanguage language) : base(language)
	{
		_language = language;
	}

	/// <inheritdoc/>
        public override INode CreateNode(string id, Classifier classifier)
	{
		if (_language.IfaceImplA.EqualsIdentity(classifier))
			return NewIfaceImplA(id);
		if (_language.IfaceImplB.EqualsIdentity(classifier))
			return NewIfaceImplB(id);
		if (_language.IfaceMethod.EqualsIdentity(classifier))
			return NewIfaceMethod(id);
		if (_language.SubConceptA.EqualsIdentity(classifier))
			return NewSubConceptA(id);
		if (_language.SubConceptB.EqualsIdentity(classifier))
			return NewSubConceptB(id);
		throw new UnsupportedClassifierException(classifier);
	}

	/// <inheritdoc/>
        public override Enum GetEnumerationLiteral(EnumerationLiteral literal)
	{
		throw new UnsupportedEnumerationLiteralException(literal);
	}

	/// <inheritdoc/>
        public override IStructuredDataTypeInstance CreateStructuredDataTypeInstance(StructuredDataType structuredDataType, IFieldValues fieldValues)
	{
		throw new UnsupportedStructuredDataTypeException(structuredDataType);
	}

	public virtual IfaceImplA NewIfaceImplA(string id) => new(id);
	public virtual IfaceImplA CreateIfaceImplA() => NewIfaceImplA(GetNewId());
	public virtual IfaceImplB NewIfaceImplB(string id) => new(id);
	public virtual IfaceImplB CreateIfaceImplB() => NewIfaceImplB(GetNewId());
	public virtual IfaceMethod NewIfaceMethod(string id) => new(id);
	public virtual IfaceMethod CreateIfaceMethod() => NewIfaceMethod(GetNewId());
	public virtual SubConceptA NewSubConceptA(string id) => new(id);
	public virtual SubConceptA CreateSubConceptA() => NewSubConceptA(GetNewId());
	public virtual SubConceptB NewSubConceptB(string id) => new(id);
	public virtual SubConceptB CreateSubConceptB() => NewSubConceptB(GetNewId());
}

[LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-BaseConceptA")]
public abstract partial class BaseConceptA : ConceptInstanceBase
{
	private string? _baseConceptA_ = null;
	private bool SetBaseConceptARaw(string? value)
	{
		if (value == _baseConceptA_)
			return false;
		_baseConceptA_ = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If BaseConceptA_ has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-BaseConceptA")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string BaseConceptA_ { get => _baseConceptA_ ?? throw new UnsetFeatureException(FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptA_BaseConceptA); set => SetBaseConceptA(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetBaseConceptA([NotNullWhenAttribute(true)] out string? baseConceptA_)
	{
		baseConceptA_ = _baseConceptA_;
		return baseConceptA_ != null;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public BaseConceptA SetBaseConceptA(string value)
	{
		SetRequiredReferenceTypeProperty<string>(value, FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptA_BaseConceptA, _baseConceptA_, SetBaseConceptARaw);
		return this;
	}

	public BaseConceptA(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptA;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptA_BaseConceptA.EqualsIdentity(feature))
		{
			result = BaseConceptA_;
			return true;
		}

		return false;
	}

	protected override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptA_BaseConceptA.EqualsIdentity(feature))
		{
			result = _baseConceptA_;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value)
	{
		if (base.SetInternal(feature, value))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptA_BaseConceptA.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				SetBaseConceptA(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptA_BaseConceptA.EqualsIdentity(feature) && value is null or string)
			return SetBaseConceptARaw((string?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetBaseConceptA(out _))
			result.Add(FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptA_BaseConceptA);
		return result;
	}
}

[LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-BaseConceptB")]
public abstract partial class BaseConceptB : ConceptInstanceBase
{
	private string? _subConceptB_ = null;
	private bool SetSubConceptBRaw(string? value)
	{
		if (value == _subConceptB_)
			return false;
		_subConceptB_ = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If SubConceptB_ has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-SubConceptB")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string SubConceptB_ { get => _subConceptB_ ?? throw new UnsetFeatureException(FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptB_SubConceptB); set => SetSubConceptB(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetSubConceptB([NotNullWhenAttribute(true)] out string? subConceptB_)
	{
		subConceptB_ = _subConceptB_;
		return subConceptB_ != null;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public BaseConceptB SetSubConceptB(string value)
	{
		SetRequiredReferenceTypeProperty<string>(value, FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptB_SubConceptB, _subConceptB_, SetSubConceptBRaw);
		return this;
	}

	public BaseConceptB(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptB;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptB_SubConceptB.EqualsIdentity(feature))
		{
			result = SubConceptB_;
			return true;
		}

		return false;
	}

	protected override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptB_SubConceptB.EqualsIdentity(feature))
		{
			result = _subConceptB_;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value)
	{
		if (base.SetInternal(feature, value))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptB_SubConceptB.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				SetSubConceptB(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptB_SubConceptB.EqualsIdentity(feature) && value is null or string)
			return SetSubConceptBRaw((string?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetSubConceptB(out _))
			result.Add(FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptB_SubConceptB);
		return result;
	}
}

[LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-BaseConceptC")]
public abstract partial class BaseConceptC : ConceptInstanceBase
{
	private string? _baseConceptD = null;
	private bool SetBaseConceptDRaw(string? value)
	{
		if (value == _baseConceptD)
			return false;
		_baseConceptD = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If BaseConceptD has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-BaseConceptD")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string BaseConceptD { get => _baseConceptD ?? throw new UnsetFeatureException(FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptC_BaseConceptD); set => SetBaseConceptD(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetBaseConceptD([NotNullWhenAttribute(true)] out string? baseConceptD)
	{
		baseConceptD = _baseConceptD;
		return baseConceptD != null;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public BaseConceptC SetBaseConceptD(string value)
	{
		SetRequiredReferenceTypeProperty<string>(value, FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptC_BaseConceptD, _baseConceptD, SetBaseConceptDRaw);
		return this;
	}

	public BaseConceptC(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptC;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptC_BaseConceptD.EqualsIdentity(feature))
		{
			result = BaseConceptD;
			return true;
		}

		return false;
	}

	protected override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptC_BaseConceptD.EqualsIdentity(feature))
		{
			result = _baseConceptD;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value)
	{
		if (base.SetInternal(feature, value))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptC_BaseConceptD.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				SetBaseConceptD(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptC_BaseConceptD.EqualsIdentity(feature) && value is null or string)
			return SetBaseConceptDRaw((string?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetBaseConceptD(out _))
			result.Add(FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptC_BaseConceptD);
		return result;
	}
}

[LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-BaseConceptD")]
public abstract partial class BaseConceptD : ConceptInstanceBase
{
	private string? _baseConceptE = null;
	private bool SetBaseConceptERaw(string? value)
	{
		if (value == _baseConceptE)
			return false;
		_baseConceptE = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If BaseConceptE has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-BaseConceptE")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string BaseConceptE { get => _baseConceptE ?? throw new UnsetFeatureException(FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptD_BaseConceptE); set => SetBaseConceptE(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetBaseConceptE([NotNullWhenAttribute(true)] out string? baseConceptE)
	{
		baseConceptE = _baseConceptE;
		return baseConceptE != null;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public BaseConceptD SetBaseConceptE(string value)
	{
		SetRequiredReferenceTypeProperty<string>(value, FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptD_BaseConceptE, _baseConceptE, SetBaseConceptERaw);
		return this;
	}

	public BaseConceptD(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptD;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptD_BaseConceptE.EqualsIdentity(feature))
		{
			result = BaseConceptE;
			return true;
		}

		return false;
	}

	protected override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptD_BaseConceptE.EqualsIdentity(feature))
		{
			result = _baseConceptE;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value)
	{
		if (base.SetInternal(feature, value))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptD_BaseConceptE.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				SetBaseConceptE(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptD_BaseConceptE.EqualsIdentity(feature) && value is null or string)
			return SetBaseConceptERaw((string?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetBaseConceptE(out _))
			result.Add(FeatureSameNameAsContainingConceptLanguage.Instance.BaseConceptD_BaseConceptE);
		return result;
	}
}

[LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-Iface")]
public partial interface Iface : INode
{
	/// <remarks>Required Property</remarks>
        [LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-IfaceMethod")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string IfaceMethod_ { get; set; }

	/// <remarks>Required Property</remarks>
        public Iface SetIfaceMethod(string value);
}

[LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-IfaceImplA")]
public partial class IfaceImplA : ConceptInstanceBase, Iface
{
	private string? _ifaceMethod_ = null;
	private bool SetIfaceMethodRaw(string? value)
	{
		if (value == _ifaceMethod_)
			return false;
		_ifaceMethod_ = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If IfaceMethod_ has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-IfaceMethod")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string IfaceMethod_ { get => _ifaceMethod_ ?? throw new UnsetFeatureException(FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod); set => SetIfaceMethod(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetIfaceMethod([NotNullWhenAttribute(true)] out string? ifaceMethod_)
	{
		ifaceMethod_ = _ifaceMethod_;
		return ifaceMethod_ != null;
	}
/// <remarks>Required Property</remarks>
/// <exception cref="InvalidValueException">If set to null</exception>
 Iface Iface.SetIfaceMethod(string value) => SetIfaceMethod(value);
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public IfaceImplA SetIfaceMethod(string value)
	{
		SetRequiredReferenceTypeProperty<string>(value, FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod, _ifaceMethod_, SetIfaceMethodRaw);
		return this;
	}

	public IfaceImplA(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => FeatureSameNameAsContainingConceptLanguage.Instance.IfaceImplA;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod.EqualsIdentity(feature))
		{
			result = IfaceMethod_;
			return true;
		}

		return false;
	}

	protected override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod.EqualsIdentity(feature))
		{
			result = _ifaceMethod_;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value)
	{
		if (base.SetInternal(feature, value))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				SetIfaceMethod(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod.EqualsIdentity(feature) && value is null or string)
			return SetIfaceMethodRaw((string?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetIfaceMethod(out _))
			result.Add(FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod);
		return result;
	}
}

[LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-IfaceImplB")]
public partial class IfaceImplB : ConceptInstanceBase, Iface
{
	private string? _ifaceMethod_ = null;
	private bool SetIfaceMethodRaw(string? value)
	{
		if (value == _ifaceMethod_)
			return false;
		_ifaceMethod_ = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If IfaceMethod_ has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-IfaceMethod")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string IfaceMethod_ { get => _ifaceMethod_ ?? throw new UnsetFeatureException(FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod); set => SetIfaceMethod(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetIfaceMethod([NotNullWhenAttribute(true)] out string? ifaceMethod_)
	{
		ifaceMethod_ = _ifaceMethod_;
		return ifaceMethod_ != null;
	}
/// <remarks>Required Property</remarks>
/// <exception cref="InvalidValueException">If set to null</exception>
 Iface Iface.SetIfaceMethod(string value) => SetIfaceMethod(value);
	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public IfaceImplB SetIfaceMethod(string value)
	{
		SetRequiredReferenceTypeProperty<string>(value, FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod, _ifaceMethod_, SetIfaceMethodRaw);
		return this;
	}

	public IfaceImplB(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => FeatureSameNameAsContainingConceptLanguage.Instance.IfaceImplB;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod.EqualsIdentity(feature))
		{
			result = IfaceMethod_;
			return true;
		}

		return false;
	}

	protected override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod.EqualsIdentity(feature))
		{
			result = _ifaceMethod_;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value)
	{
		if (base.SetInternal(feature, value))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				SetIfaceMethod(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod.EqualsIdentity(feature) && value is null or string)
			return SetIfaceMethodRaw((string?)value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetIfaceMethod(out _))
			result.Add(FeatureSameNameAsContainingConceptLanguage.Instance.Iface_IfaceMethod);
		return result;
	}
}

[LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-IfaceMethod")]
public partial class IfaceMethod : IfaceImplA
{
	public IfaceMethod(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => FeatureSameNameAsContainingConceptLanguage.Instance.IfaceMethod;
}

[LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-SubConceptA")]
public partial class SubConceptA : BaseConceptA
{
	public SubConceptA(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => FeatureSameNameAsContainingConceptLanguage.Instance.SubConceptA;
}

[LionCoreMetaPointer(Language = typeof(FeatureSameNameAsContainingConceptLanguage), Key = "key-SubConceptB")]
public partial class SubConceptB : BaseConceptB
{
	public SubConceptB(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => FeatureSameNameAsContainingConceptLanguage.Instance.SubConceptB;
}