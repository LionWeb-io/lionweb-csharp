// Generated by the C# M2TypesGenerator: modify at your own risk!
// ReSharper disable InconsistentNaming
// ReSharper disable SuggestVarOrType_SimpleTypes
// ReSharper disable SuggestVarOrType_Elsewhere
#pragma warning disable 1591
#nullable enable
namespace LionWeb.Core.Test.Languages.Generated.V2024_1.MYUpperCaseLang;
using LionWeb.Core;
using LionWeb.Core.M2;
using LionWeb.Core.M3;
using LionWeb.Core.Notification;
using LionWeb.Core.Utilities;
using LionWeb.Core.VersionSpecific.V2024_1;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

[LionCoreLanguage(Key = "key-UpperCaseLang", Version = "1")]
public partial class MYUpperCaseLangLanguage : LanguageBase<IMYUpperCaseLangFactory>
{
	public static readonly MYUpperCaseLangLanguage Instance = new Lazy<MYUpperCaseLangLanguage>(() => new("id-UpperCase-lang")).Value;
	public MYUpperCaseLangLanguage(string id) : base(id, LionWebVersions.v2024_1)
	{
		_mYAnnotation = new(() => new AnnotationBase<MYUpperCaseLangLanguage>("id-annotation", this) { Key = "key-annotation", Name = "MYAnnotation", AnnotatesLazy = new(() => _builtIns.Node) });
		_mYConcept = new(() => new ConceptBase<MYUpperCaseLangLanguage>("id-concept", this) { Key = "key-concept", Name = "MYConcept", Abstract = false, Partition = false, FeaturesLazy = new(() => [MYConcept_MYContainment, MYConcept_MYProperty, MYConcept_MYReference]) });
		_mYConcept_MYContainment = new(() => new ContainmentBase<MYUpperCaseLangLanguage>("id-containment", MYConcept, this) { Key = "key-containment", Name = "MYContainment", Optional = false, Multiple = false, Type = _builtIns.Node });
		_mYConcept_MYProperty = new(() => new PropertyBase<MYUpperCaseLangLanguage>("id-property", MYConcept, this) { Key = "key-property", Name = "MYProperty", Optional = false, Type = _builtIns.String });
		_mYConcept_MYReference = new(() => new ReferenceBase<MYUpperCaseLangLanguage>("id-reference", MYConcept, this) { Key = "key-reference", Name = "MYReference", Optional = false, Multiple = false, Type = _builtIns.Node });
		_mYEnum = new(() => new EnumerationBase<MYUpperCaseLangLanguage>("id-enumeration", this) { Key = "key-enumeration", Name = "MYEnum", LiteralsLazy = new(() => [MYEnum_MYLiteral]) });
		_mYEnum_MYLiteral = new(() => new EnumerationLiteralBase<MYUpperCaseLangLanguage>("id-literal", MYEnum, this) { Key = "key-literal", Name = "MYLiteral" });
		_mYSdt = new(() => new StructuredDataTypeBase<MYUpperCaseLangLanguage>("id-sdt", this) { Key = "key-sdt", Name = "MYSdt", FieldsLazy = new(() => [MYSdt_MYField]) });
		_mYSdt_MYField = new(() => new FieldBase<MYUpperCaseLangLanguage>("id-field", MYSdt, this) { Key = "key-field", Name = "MYField", Type = _builtIns.String });
		_factory = new MYUpperCaseLangFactory(this);
	}

	/// <inheritdoc/>
        public override IReadOnlyList<LanguageEntity> Entities => [MYAnnotation, MYConcept, MYEnum, MYSdt];
	/// <inheritdoc/>
        public override IReadOnlyList<Language> DependsOn => [];

	private const string _key = "key-UpperCaseLang";
	/// <inheritdoc/>
        public override string Key => _key;

	private const string _name = "MYUpperCaseLang";
	/// <inheritdoc/>
        public override string Name => _name;

	private const string _version = "1";
	/// <inheritdoc/>
        public override string Version => _version;

	private readonly Lazy<Annotation> _mYAnnotation;
	public Annotation MYAnnotation => _mYAnnotation.Value;

	private readonly Lazy<Concept> _mYConcept;
	public Concept MYConcept => _mYConcept.Value;

	private readonly Lazy<Containment> _mYConcept_MYContainment;
	public Containment MYConcept_MYContainment => _mYConcept_MYContainment.Value;

	private readonly Lazy<Property> _mYConcept_MYProperty;
	public Property MYConcept_MYProperty => _mYConcept_MYProperty.Value;

	private readonly Lazy<Reference> _mYConcept_MYReference;
	public Reference MYConcept_MYReference => _mYConcept_MYReference.Value;

	private readonly Lazy<Enumeration> _mYEnum;
	public Enumeration MYEnum => _mYEnum.Value;

	private readonly Lazy<EnumerationLiteral> _mYEnum_MYLiteral;
	public EnumerationLiteral MYEnum_MYLiteral => _mYEnum_MYLiteral.Value;

	private readonly Lazy<StructuredDataType> _mYSdt;
	public StructuredDataType MYSdt => _mYSdt.Value;

	private readonly Lazy<Field> _mYSdt_MYField;
	public Field MYSdt_MYField => _mYSdt_MYField.Value;
}

public partial interface IMYUpperCaseLangFactory : INodeFactory
{
	public MYAnnotation NewMYAnnotation(string id);
	public MYAnnotation CreateMYAnnotation();
	public MYConcept NewMYConcept(string id);
	public MYConcept CreateMYConcept();
}

public class MYUpperCaseLangFactory : AbstractBaseNodeFactory, IMYUpperCaseLangFactory
{
	private readonly MYUpperCaseLangLanguage _language;
	public MYUpperCaseLangFactory(MYUpperCaseLangLanguage language) : base(language)
	{
		_language = language;
	}

	/// <inheritdoc/>
        public override INode CreateNode(string id, Classifier classifier)
	{
		if (_language.MYAnnotation.EqualsIdentity(classifier))
			return NewMYAnnotation(id);
		if (_language.MYConcept.EqualsIdentity(classifier))
			return NewMYConcept(id);
		throw new UnsupportedClassifierException(classifier);
	}

	/// <inheritdoc/>
        public override Enum GetEnumerationLiteral(EnumerationLiteral literal)
	{
		if (_language.MYEnum.EqualsIdentity(literal.GetEnumeration()))
			return EnumValueFor<MYEnum>(literal);
		throw new UnsupportedEnumerationLiteralException(literal);
	}

	/// <inheritdoc/>
        public override IStructuredDataTypeInstance CreateStructuredDataTypeInstance(StructuredDataType structuredDataType, IFieldValues fieldValues)
	{
		if (_language.MYSdt.EqualsIdentity(structuredDataType))
			return new MYSdt((string?)fieldValues.Get(_language.MYSdt_MYField));
		throw new UnsupportedStructuredDataTypeException(structuredDataType);
	}

	public virtual MYAnnotation NewMYAnnotation(string id) => new(id);
	public virtual MYAnnotation CreateMYAnnotation() => NewMYAnnotation(GetNewId());
	public virtual MYConcept NewMYConcept(string id) => new(id);
	public virtual MYConcept CreateMYConcept() => NewMYConcept(GetNewId());
}

/// <seealso cref = "MYUpperCaseLangLanguage"/>
/// <seealso cref = "MYConcept"/>
/// <seealso cref = "MYConcept.MYProperty"/>
/// <seealso cref = "MYConcept.MYReference"/>
/// <seealso cref = "MYConcept.MYContainment"/>
/// <seealso cref = "MYEnum"/>
/// <seealso cref = "MYEnum.MYLiteral"/>
/// <seealso cref = "MYSdt"/>
/// <seealso cref = "MYSdt.MYField"/>
/// <seealso cref = "MYAnnotation"/>
[LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-annotation")]
public partial class MYAnnotation : AnnotationInstanceBase
{
	public MYAnnotation(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Annotation GetAnnotation() => MYUpperCaseLangLanguage.Instance.MYAnnotation;
}

[LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-concept")]
public partial class MYConcept : ConceptInstanceBase
{
	private INode? _mYContainment = null;
	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "UnsetFeatureException">If MYContainment has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-containment")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Containment, Optional = false, Multiple = false)]
	public INode MYContainment { get => _mYContainment ?? throw new UnsetFeatureException(MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment); set => SetMYContainment(value); }

	/// <remarks>Required Single Containment</remarks>
        public bool TryGetMYContainment([NotNullWhenAttribute(true)] out INode? mYContainment)
	{
		mYContainment = _mYContainment;
		return mYContainment != null;
	}

	private bool SetMYContainmentRaw(INode? value)
	{
		if (!ExchangeChildRaw(value, _mYContainment))
			return false;
		_mYContainment = value;
		return true;
	}

	/// <remarks>Required Single Containment</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public MYConcept SetMYContainment(INode value)
	{
		SetRequiredSingleContainment<INode>(value, MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment, _mYContainment, SetMYContainmentRaw);
		return this;
	}

	private string? _mYProperty = null;
	private bool SetMYPropertyRaw(string? value)
	{
		if (value == _mYProperty)
			return false;
		_mYProperty = value;
		return true;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "UnsetFeatureException">If MYProperty has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-property")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = false, Multiple = false)]
	public string MYProperty { get => _mYProperty ?? throw new UnsetFeatureException(MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty); set => SetMYProperty(value); }

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public bool TryGetMYProperty([NotNullWhenAttribute(true)] out string? mYProperty)
	{
		mYProperty = _mYProperty;
		return mYProperty != null;
	}

	/// <remarks>Required Property</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public MYConcept SetMYProperty(string value)
	{
		SetRequiredReferenceTypeProperty<string>(value, MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty, _mYProperty, SetMYPropertyRaw);
		return this;
	}

	private ReferenceTarget? _mYReference = null;
	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "UnsetFeatureException">If MYReference has not been set</exception>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        [LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-reference")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Reference, Optional = false, Multiple = false)]
	public IReadableNode MYReference { get => ReferenceTargetNonNullTarget<IReadableNode>(_mYReference, MYUpperCaseLangLanguage.Instance.MYConcept_MYReference) ?? throw new UnsetFeatureException(MYUpperCaseLangLanguage.Instance.MYConcept_MYReference); set => SetMYReference(value); }

	/// <remarks>Required Single Reference</remarks>
        public bool TryGetMYReference([NotNullWhenAttribute(true)] out IReadableNode? mYReference)
	{
		mYReference = ReferenceTargetNullableTarget<IReadableNode>(_mYReference, MYUpperCaseLangLanguage.Instance.MYConcept_MYReference);
		return mYReference != null;
	}

	private MYConcept SetMYReference(ReferenceTarget? value)
	{
		SetRequiredSingleReference<IReadableNode>(value, MYUpperCaseLangLanguage.Instance.MYConcept_MYReference, _mYReference, SetMYReferenceRaw);
		return this;
	}

	private bool SetMYReferenceRaw(ReferenceTarget? value)
	{
		if (value == _mYReference)
			return false;
		_mYReference = value;
		return true;
	}

	/// <remarks>Required Single Reference</remarks>
    	/// <exception cref = "InvalidValueException">If set to null</exception>
        public MYConcept SetMYReference(IReadableNode value)
	{
		return SetMYReference(ReferenceTarget.FromNodeOptional(value));
	}

	public MYConcept(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Concept GetConcept() => MYUpperCaseLangLanguage.Instance.MYConcept;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment.EqualsIdentity(feature))
		{
			result = MYContainment;
			return true;
		}

		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty.EqualsIdentity(feature))
		{
			result = MYProperty;
			return true;
		}

		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYReference.EqualsIdentity(feature))
		{
			result = MYReference;
			return true;
		}

		return false;
	}

	protected override bool TryGetPropertyRaw(Property feature, out object? result)
	{
		if (base.TryGetPropertyRaw(feature, out result))
			return true;
		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty.EqualsIdentity(feature))
		{
			result = _mYProperty;
			return true;
		}

		return false;
	}

	protected override bool TryGetContainmentRaw(Containment feature, out IReadableNode? result)
	{
		if (base.TryGetContainmentRaw(feature, out result))
			return true;
		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment.EqualsIdentity(feature))
		{
			result = _mYContainment;
			return true;
		}

		return false;
	}

	protected override bool TryGetReferenceRaw(Reference feature, out IReferenceTarget? result)
	{
		if (base.TryGetReferenceRaw(feature, out result))
			return true;
		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYReference.EqualsIdentity(feature))
		{
			result = _mYReference;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value)
	{
		if (base.SetInternal(feature, value))
			return true;
		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment.EqualsIdentity(feature))
		{
			if (value is INode v)
			{
				SetMYContainment(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty.EqualsIdentity(feature))
		{
			if (value is string v)
			{
				SetMYProperty(v);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYReference.EqualsIdentity(feature))
		{
			if (value is IReadableNode v)
			{
				SetMYReference(v);
				return true;
			}

			if (value is ReferenceTarget target)
			{
				SetMYReference(target);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	protected override bool SetPropertyRaw(Property feature, object? value)
	{
		if (base.SetPropertyRaw(feature, value))
			return true;
		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty.EqualsIdentity(feature) && value is null or string)
			return SetMYPropertyRaw((string?)value);
		return false;
	}

	protected override bool SetContainmentRaw(Containment feature, IWritableNode? value)
	{
		if (base.SetContainmentRaw(feature, value))
			return true;
		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment.EqualsIdentity(feature) && value is null or INode)
			return SetMYContainmentRaw((INode?)value);
		return false;
	}

	protected override bool SetReferenceRaw(Reference feature, ReferenceTarget? value)
	{
		if (base.SetReferenceRaw(feature, value))
			return true;
		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYReference.EqualsIdentity(feature))
			return SetMYReferenceRaw(value);
		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetMYContainment(out _))
			result.Add(MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment);
		if (TryGetMYProperty(out _))
			result.Add(MYUpperCaseLangLanguage.Instance.MYConcept_MYProperty);
		if (TryGetMYReference(out _))
			result.Add(MYUpperCaseLangLanguage.Instance.MYConcept_MYReference);
		return result;
	}

	/// <inheritdoc/>
        protected override bool DetachChild(INode child)
	{
		if (base.DetachChild(child))
			return true;
		Containment? c = GetContainmentOf(child);
		if (MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment.EqualsIdentity(c))
		{
			_mYContainment = null;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        public override Containment? GetContainmentOf(INode child)
	{
		Containment? result = base.GetContainmentOf(child);
		if (result != null)
			return result;
		if (ReferenceEquals(_mYContainment, child))
			return MYUpperCaseLangLanguage.Instance.MYConcept_MYContainment;
		return null;
	}
}

[LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-enumeration")]
public enum MYEnum
{
	[LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-literal")]
	MYLiteral
}

[LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-sdt")]
public readonly record struct MYSdt : IStructuredDataTypeInstance
{
	private readonly string? _mYField;
	[LionCoreMetaPointer(Language = typeof(MYUpperCaseLangLanguage), Key = "key-field")]
	public string MYField { get => _mYField ?? throw new UnsetFieldException(MYUpperCaseLangLanguage.Instance.MYSdt_MYField); init => _mYField = value; }

	public MYSdt()
	{
		_mYField = null;
	}

	internal MYSdt(string? mYField)
	{
		_mYField = mYField;
	}

	/// <inheritdoc/>
        public StructuredDataType GetStructuredDataType() => MYUpperCaseLangLanguage.Instance.MYSdt;
	/// <inheritdoc/>
        public IEnumerable<Field> CollectAllSetFields()
	{
		List<Field> result = [];
		if (_mYField != null)
			result.Add(MYUpperCaseLangLanguage.Instance.MYSdt_MYField);
		return result;
	}

	/// <inheritdoc/>
        public object? Get(Field field)
	{
		if (MYUpperCaseLangLanguage.Instance.MYSdt_MYField.EqualsIdentity(field))
			return MYField;
		throw new UnsetFieldException(field);
	}

	public override string ToString() => $"MYSdt {{ MYField = {_mYField} }}";
}