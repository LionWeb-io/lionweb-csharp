// Copyright 2024 TRUMPF Laser SE and other contributors
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 
// SPDX-FileCopyrightText: 2024 TRUMPF Laser SE and other contributors
// SPDX-License-Identifier: Apache-2.0

namespace LionWeb.CSharp.Generator.Impl;

using Core.M2;
using Core.M3;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Names;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static AstExtensions;
using Property = Core.M3.Property;

/// <summary>
/// Generates constructor of Language class.
/// </summary>
public class LanguageConstructorGenerator(INames names) : LanguageGeneratorBase(names)
{
    /// <inheritdoc cref="LanguageConstructorGenerator"/>
    public ConstructorDeclarationSyntax GenConstructor() =>
        Constructor(LanguageName, Param("id", AsType(typeof(string))))
            .WithInitializer(Initializer("id"))
            .WithBody(AsStatements(
                Language.Entities.Ordered().SelectMany(EntityConstructorInitialization)
                    .Append(GenFactoryInitialization())
            ));

    private StatementSyntax GenFactoryInitialization() =>
        Assignment("_factory", NewCall([This()], _names.FactoryType));

    private IEnumerable<StatementSyntax> EntityConstructorInitialization(LanguageEntity entity)
    {
        (var properties, var metaType) = entity switch
        {
            Annotation a => EntityConstructorInitialization(a),
            Concept c => EntityConstructorInitialization(c),
            Interface i => EntityConstructorInitialization(i),
            Enumeration e => EntityConstructorInitialization(e),
            PrimitiveType p => EntityConstructorInitialization(p),
            _ => throw new ArgumentException($"unsupported entity: {entity}", nameof(entity))
        };

        if (properties.Count == 0)
            return [];

        var result = new List<StatementSyntax>
        {
            Assignment(LanguageFieldName(entity), NewLazy(
                NewCall([entity.GetId().AsLiteral(), ThisExpression()],
                    metaType, properties.ToArray())
            ))
        };

        switch (entity)
        {
            case Classifier classifier:
                result.AddRange(classifier.Features.Select(FeatureConstructorInitialization));
                break;
            case Enumeration enumeration:
                result.AddRange(enumeration.Literals.Select(LiteralConstructorInitialization));
                break;
            default:
                // fall-through
                break;
        }

        return result;
    }

    #region LanguageEntity

    private (List<(string, ExpressionSyntax)>, TypeSyntax) EntityConstructorInitialization(Annotation annotation)
    {
        var result = KeyName(annotation);
        result.Add(("AnnotatesLazy", NewLazy(AsProperty(annotation.Annotates ?? BuiltInsLanguage.Instance.Node))));
        result.AddRange(Extends(annotation.Extends));
        result.AddRange(Implements("ImplementsLazy", annotation.Implements));
        result.AddRange(Features(annotation));

        return (result, AsType(typeof(AnnotationBase<>), generics: LanguageType));
    }

    private (List<(string, ExpressionSyntax)>, TypeSyntax) EntityConstructorInitialization(Concept concept)
    {
        var result = KeyName(concept);
        result.Add(("Abstract", concept.Abstract.AsLiteral()));
        result.Add(("Partition", concept.Partition.AsLiteral()));
        result.AddRange(Extends(concept.Extends));
        result.AddRange(Implements("ImplementsLazy", concept.Implements));
        result.AddRange(Features(concept));

        return (result, AsType(typeof(ConceptBase<>), generics: LanguageType));
    }

    private (List<(string, ExpressionSyntax)>, TypeSyntax) EntityConstructorInitialization(Interface iface)
    {
        var result = KeyName(iface);
        result.AddRange(Implements("ExtendsLazy", iface.Extends));
        result.AddRange(Features(iface));

        return (result, AsType(typeof(InterfaceBase<>), generics: LanguageType));
    }

    private (List<(string, ExpressionSyntax)>, TypeSyntax) EntityConstructorInitialization(Enumeration enumeration)
    {
        var result = KeyName(enumeration);
        result.Add(("LiteralsLazy", NewLazy(Collection(enumeration.Literals.Select(AsProperty)))));

        return (result, AsType(typeof(EnumerationBase<>), generics: LanguageType));
    }

    private (List<(string, ExpressionSyntax)>, TypeSyntax) EntityConstructorInitialization(PrimitiveType primitive) =>
        (KeyName(primitive), AsType(typeof(PrimitiveTypeBase<>), generics: LanguageType));

    private IEnumerable<(string, ExpressionSyntax)> Extends(Classifier? extends)
    {
        if (extends == null)
            return [];

        return [("ExtendsLazy", NewLazy(AsProperty(extends)))];
    }

    private IEnumerable<(string, ExpressionSyntax)> Implements(string key, IEnumerable<Interface>? ifaces)
    {
        var enumerable = ifaces?.ToList();
        if (enumerable == null || enumerable.Count == 0)
            return [];

        return [(key, NewLazy(Collection(enumerable.Select(AsProperty))))];
    }

    private IEnumerable<(string, ExpressionSyntax)> Features(Classifier classifier)
    {
        if (!classifier.Features.Any())
            return [];

        return [("FeaturesLazy", NewLazy(Collection(classifier.Features.Select(feature => _names.AsProperty(feature)))))];
    }

    #endregion

    private StatementSyntax FeatureConstructorInitialization(Feature feature)
    {
        var properties = KeyName(feature);
        properties.Add(("Optional", feature.Optional.AsLiteral()));

        TypeSyntax? metaType;
        ExpressionSyntax type;

        switch (feature)
        {
            case Property p:
                metaType = AsType(typeof(PropertyBase<>), generics: LanguageType);
                type = AsProperty(p.Type);
                break;
            case Containment c:
                properties.Add(("Multiple", c.Multiple.AsLiteral()));
                metaType = AsType(typeof(ContainmentBase<>), generics: LanguageType);
                type = AsProperty(c.Type);
                break;
            case Reference c:
                properties.Add(("Multiple", c.Multiple.AsLiteral()));
                metaType = AsType(typeof(ReferenceBase<>), generics: LanguageType);
                type = AsProperty(c.Type);
                break;
            default:
                throw new ArgumentException($"unsupported feature: {feature}", nameof(feature));
        }

        properties.Add(("Type", type));

        return Assignment(LanguageFieldName(feature), NewLazy(
            NewCall(
                [feature.GetId().AsLiteral(), AsProperty(feature.GetFeatureClassifier()), ThisExpression()],
                metaType,
                properties.ToArray()
            )
        ));
    }

    private StatementSyntax LiteralConstructorInitialization(EnumerationLiteral literal)
    {
        var properties = KeyName(literal);

        return Assignment(LanguageFieldName(literal), NewLazy(
            NewCall(
                [literal.GetId().AsLiteral(), AsProperty(literal.GetEnumeration()), ThisExpression()],
                AsType(typeof(EnumerationLiteralBase<>), generics: LanguageType),
                properties.ToArray()
            )
        ));
    }

    private List<(string, ExpressionSyntax)> KeyName(IKeyed keyed) =>
    [
        ("Key", keyed.Key.AsLiteral()),
        ("Name", keyed.Name.AsLiteral())
    ];
}